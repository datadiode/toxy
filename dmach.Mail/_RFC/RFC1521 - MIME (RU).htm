<HTML>
<meta http-equiv="Content-Type" content="text/html; Charset=Windows-1251" />
<META NAME="Description" CONTENT="Неполный русский перевод спецификации RFC 1521. MIME - Multipurpose Internet Mail Extensions. Part one. Mechanismes for Specifying and Describing the Format of Internet Message Bodies">
<title>Почтовый стандарт MIME (RFC1521)</title>
</head>
<body bgcolor="#E8E8E8" text="#404040" link="#000000" vlink="#808080" alink="#000000">
<h2 align="center">Почтовый стандарт MIME (RFC1521)</h2>
<p align="justify">
Документ предсталяет собой неполный русский перевод спецификации RFC 1521
<I>"MIME - Multipurpose Internet Mail Extensions. Part one. Mechanismes for Specifying and Describing the Format of Internet Message
Bodies"</I>.
<p align="right">Автор перевода: <A HREF="http://www.urc.ac.ru/~anton">Антон Воронин</A> <A HREF="mailto:anton@urc.ac.ru">anton@urc.ac.ru</A></p>
<p align="justify">
MIME  означает  "Multipurpose  Internet  Mail   Extensions"    (Многоцелевые
расширения  почтового  стандарта  Internet).  Этот  стандарт  описывает  как
пересылать по электронной почте  исполняемые,  графические,  мультимедийные,
смешаные  данные.  Типичные  применения  MIME  -    пересылка    графических
изображений, аудио,  документов  Word,  программ  и  даже  просто  текстовых
файлов, то есть, когда важно, чтобы входе пересылки не производилось никаких
преобразований над данными. MIME также позволяет размечать письмо  на  части
различных типов так, чтобы получатель (почтовая программа)  мог  определить,
что делать с каждой из частей письма.
<p align="justify">
Как читать письма в стандарте MIME?
Т.к. MIME используется всего несколько лет, еще существуют  старые  почтовые
программы, которые не понимают MIME. Однако, растет число почтовых программ,
имеющих встроенную поддержку  MIME  (одна  из  самых  популярных  -  "Pine",
разработанная в Вашингтонском  университете  и  реализованная  для  платформ
UNIX, VMS, DOS, Windows). К тому же в некоторых  почтовых  системах  имеются
специальные шлюзы, обеспечивающие MIME-трансляцию. Но даже если  у  вас  нет
возможности использовать MIME-совместимую почтовую программу и нет доступа к
подобному шлюзу, то можно также воспользоваться  рядом  программ,  способных
интерпретировать письма в MIME, сохраненные рпочтовой  программой  в  файле.
Например, програма "munpack",  созданная  в  университете  Carnegie  Mellon.
Существуют ее версии для Unix, PC, Macintosh, Amiga. <p align="justify">
Долгое время для  кодирования  бинарных  файлов  в  7-битный  формат  (чтобы
обеспечить  их  пересылку  по  почтовой  системе  Internet)   использовалась
кодировка UUENCODE,  имеющая  ряд  технических  ограничений.  Стандарт  MIME
предполагает  использовние  более  устойчивой  кодировки  "Base64",  которая
специально разработана для обеспечения сохранности данных,  пересылаемых  по
email, при различных преобразованиях,  имиеющих  место  в  ходе  прохождения
почтовых шлюзов. <p align="justify">
Стандарт MIME полностью описан в RFC-1521
<p align="justify">
<UL>
<LI>   <b><a href=#1>1.</a>     Введение</b>
<LI>   <b><a href=#2>2.</a>     Замечания, соглашения и обобщения</b>
<LI>   <b><a href=#3>3.</a>     Поле заголовка 'MIME-Version'</b>
<LI>   <b><a href=#4>4.</a>     Поле заголовка 'Content-Type'</b>
<LI>   <b><a href=#5>5.</a>     Поле заголовка 'Content-Transfer-Encoding'</b>
<LI>   <a href=#51>5.1.</a>   Механизм конвертации "Quoted-Printable"
<LI>   <a href=#52>5.2.</a>   Механизм конвертации Base64
<LI>   <b><a href=#6>6.</a>     Дополнительные поля 'Content-'</b>
<LI>   <a href=#61>6.1.</a>   Необязательное поле заголовка 'Content-ID'
<LI>   <a href=#62>6.2.</a>   Необязательное поле заголовка 'Content-Description'
<LI>   <b><a href=#7>7.</a>     Предопределенные значения поля 'Content-Type'</b>
<LI>   <a href=#71>7.1.</a>   Тип 'Text'
<LI>   <a href=#711>7.1.1.</a> Параметр 'charset'
<LI>   <a href=#712>7.1.2.</a> Подтип 'Text/plain'
<LI>   <a href=#72>7.2.</a>   Тип 'Multipart'
<LI>   <a href=#721>7.2.1.</a> Тип Multipart: общий синтаксис
<LI>   <a href=#722>7.2.2.</a> Подтип 'Multipart/mixed' (основной)
<LI>   <a href=#723>7.2.3.</a> Подтип 'Multipart/alternative'
<LI>   <a href=#724>7.2.4.</a> Подтип 'Multipart/digest'
<LI>   <a href=#725>7.2.5.</a> Подтип 'Multipart/parallel'
<LI>   <a href=#726>7.2.6.</a> Друтие подтипы типа 'Multipart'
<LI>   <a href=#73>7.3.</a>   Тип 'Message'
<LI>   <a href=#731>7.3.1.</a> Подтип 'Message/rfc822' (основной)
<LI>   <a href=#732>7.3.2.</a> Подтип 'Message/Partial'
<LI>   <a href=#733>7.3.3.</a> Подтип 'Message/External-Body'
<LI>   <a href=#7331>7.3.3.1.</a>  Способы доступа "ftp" и "tftp"
<LI>   <a href=#7332>7.3.3.2.</a>  Способ доступа "anon-ftp"
<LI>   <a href=#7333>7.3.3.3.</a>  Способы доступа "local-file" и "afs"
<LI>   <a href=#7334>7.3.3.4.</a>  Способ доступа "mail-server"
<LI>   <a href=#7335>7.3.3.5.</a>  Примеры и дополнительные пояснения
<LI>   <a href=#74>7.4.</a>   Тип 'Application'
<LI>   <a href=#741>7.4.1.</a> Подтип 'Application/Octet-Stream' (основной)
<LI>   <a href=#742>7.4.2.</a> Подтип 'Application/PostScript'
<LI>   <a href=#743>7.4.3.</a> Другие подтипы типа 'Application'
<LI>   <a href=#75>7.5.</a>   Тип 'Image'
<LI>   <a href=#76>7.6.</a>   Тип 'Audio'
<LI>   <a href=#77>7.7.</a>   Тип 'Video'
<LI>   <a href=#78>7.8.</a>   Экспериментальные значения поля 'Content-Type'
</UL>
<a name=1></a>
<H3>1.    Введение</H3>
<p align="justify">
   Со времени  опубликования  в  1982  г.,  стандарт  RFC  822  определил  и
полностью или частично внедрил формат текстовых  писем  в  почтовой  системе
Internet. Но с расширением его использования, обнаружился  ряд  ограничений,
заметно  ограничивающих  удовлетворение  пользовательских  потребностей.   В
частности, возможность  пересылки  нетекстовых  данных,  например,  аудио  и
графики, посто не была упомянута в RFC822, описывавшем лишь формат текстовых
сообщеий.  И  даже  в  случае  текста,  RFC  822  обошел  вниманием    нужды
пользователей, использующих расширенный набор символов, что  характерно  для
азиатских и большинства европейских языков. Итак, требовалась дополнительная
спецификация. Основное ограничение RFC822 - относительно короткие  строки  и
7-битная символьная таблица. Пользователям  дляотправки  нетекстовых  данных
приходилось конвертировать тело своего письма в  7-битную  форму  с  помощью
UUENCODE, BINHEX и др. <p align="justify">

Более очевидными стали ограничения RFC 822 при  разработке  почтовых  шлюзов
между  хостами,  использующими  стандарт  RFC822  и  хостами,  использующими
стандарт X.400. X.400 имеет механизмы для  включения  нетекстовых  данных  в
тело письма. В настоящее время стандарты для перевода почтовых сообщений из
X.400 в RFC822 предполагают, что нетекстовые части тела письма  должны  быть
сконвертированы (но не  закодированы)  в  ASCII  формат,  либо  должны  быть
"выброшены" из письма с уведомлением об этом получателя. А потеря информации
крайне не желательна для пользователя. <p align="justify">

MIME разработан как расширяемый механизм с расчетом на  то,  что  набор  пар
content-type/subtype  будет  расти  со  временем.  Некоторые  другие    поля
заголовка MIMЕ, включая имена наборов символов, также  ,  вероятно,  получат
большее число возможных значений.  С  этой  целью  MIME  определяет  процесс
регистрации через Internet Assigned  Numbers  Authority  (IANA),  как  центр
регистрации этих значений.  Описание  процесса  регистрации  можно  найти  в
приложении E RFC 1521. <p align="justify">

<a name=2></a>
<H3>2.   Замечания, соглашения и обобщения</H3>
<p align="justify">
Термины "сообщение" и "письмо" являются синонимами.  Термин  "часть  письма"
или "часть тела письма" подразумевает одну из частей  письма,  разбитого  на
части разных типов данных. Часть тела письма, в свою очередь, имеет  тело  и
заголовок, так что  имеет  смысл  говорить  о  теле  части  тела  письма.  В
дальнейшем,  при  отсутствии  оговорок,  "телом"   будем    называть    тело
рассматриваемого в данный момент объекта - части письма либо  всего  письма.
Как уже ясно, формат MIME-сообщения, в общем случае, рекурсивен. <p align="justify">


<a name=3></a>
<H3>3.  Поле заголовка "MIME-Version"</H3>
<p align="justify">

   Поскольку старый стандарт RFC 822 все еще используется, а MIME  возможно,
изменится и дополнится  в  будущем,  почтовой  программе  необходимо  знать,
применен ли новый стандарт в конкретном письме или нет. Поэтому в  заголовок
ввелено  новое  поле  "MIME-Version",  объявляющее  версию   стандарта,    в
соответствии с которым написано данное письмо. <p align="justify">

   Все почтовые сообщения, составленные в соответствии  с  MIME-стандартом,
должны иметь это поле в своем заголовке, напрмер:
<PRE>
     MIME-Version: 1.0
</PRE>

<p align="justify">
Так как возможно, в  будущем  формат  заголовка  письма  может  расшириться,
формально содержание поля "MIME-version" дается следующим образом: <p align="justify">

<PRE>
     версия := "MIME-Version" ":" 1*DIGIT "." 1*DIGIT
</PRE>

<p align="justify">
Т.о., будущие значения версии формата, коорые могут заменить  "1.0",  должны
быть целыми числами, разделенными точкой. Если письмо получено со  значением
версии MIME, отличным  от  "1.0",  оно  не  будет  рассматриваться  почтовой
программой, как соответствующее данной спецификации. <p align="justify">

Важно, что поле  заголовка  "MIME-Version",  должно  располагаться  в  самам
начале письма. Это не обязательно для каждой из частей тела письма в  случае
многочастевого письма, но обязательно для заголовков частей типа  "message",
если и только если эта часть сама по себе декларирована как  соответствующая
спецификации MIME. <p align="justify">

Не возможно полностью  определить  как  почтовая  программа,  поддерживающая
MIME,  должна  интерпретировать  письмо,  имеющее  значение    MIME-version,
отличное от "1.0". Но, как минимум, почтовая программа  должна  предупредить
пользователя о том, что письмо написано в незнакомом ей формате. <p align="justify">

Все поля заголовка, включая  MIME-Version,  Content-type,  и  т.д.,  должны
соответствовать общим синтаксическим правилам, определенным в  RFC  822.  В
частности, допускается включение комментариев (т.е.,  следующие  2  примера
эквивалентны):

<PRE>
     MIME-Version: 1.0
     MIME-Version: 1.0 (Generated by GBD-killer 3.7)
</PRE>

<a name=4></a>
<H3>4. Поле заголовка "Content-Type"</H3>
<p align="justify">
   Назначение этого поля - наиболее полное описание данных, содержащихся  в
теле, с тем, чтобы почтовый  агент  (программа)  получателя  могла  выбрать
соответствующий механизм для их обаботки. Впервые это поле было  определено
в RFC 1049, но имело более простой синтаксис.
<p align="justify">

Данное поле включает в себя идентификаторы типа и  подтипа,  а  также  может
содержать некоторую вспомогательную информацию, которая может  потребоваться
для конкретного типа данных. После идентификаторов типа и подтипа оставшаяся
часть поля - просто набор парамеров, заданных в порядке  "атрибут/значение".
Набор параметров зависит  от  типа  данных.  (В  частности,  не  может  быть
глобально-значимых параметров, справедливых сразу для всех типов содержимого
ьела письма.  Глобальные  механизмы  в  MIME-модели  реализованы  с  помощью
введения дополнительных полей "Content-*"). Очередность параметров  значения
не  имеет.  В  числе  определенных  параметров  -  "charset",  декларирующий
символьный набор (кодировку, кодовую  страницу  -  это  все  синонимы)  тела
письма. Комментарии допускаются. <p align="justify">

Вообще, поле Content-Type самого верхнего уровня используется для объявления
общего типа данных, в то время как подтип определяет специальный формат  для
данных этого типа. Так,  значение  "image/xyz"  поля  Content-Type  сообщает
пользовательской программе, что  данные  являются  графическим  изображением
(image), даже если эта почтовая программа не  имеет  понятия  о  специальном
формате "xyz" этой картинки.  Но  эта  информация  может  быть  использована
программой, например, чтобы  решить,  показывать  ли  пользователю  строкоые
данные неизвестного подтипа -- показ таких данных может  быть  оправдан  для
незнакомых подтипов текста, но не для незнакомых подтипов графики, аудио или
видео. По этой причине, данные зарегистрированного подтипа  аудио,  графики,
текста или видео не должны содержать внутри себя части другого подтипа - для
содержания  в  письме  данных  одного  типа,  но  разных  подтипов   следует
использовать тип "multipart" или "application". <p align="justify">

Хотя  многие  параметры  (модификаторы  подтипов)  имеют  смысл  лишь    для
конкретного типа, некоторые все же являются глобальными в  том  смысле.  что
они применимы ко всем типам (например, параметр "boundary" применим только с
типом "multipart", а параметр "charset" может использоваться  с  несколькими
типами). <p align="justify">

Пока  имен  типов  только  семь,  и  пока  этого  достаточно.  Кроме   того,
предполагается, что расширение  существующего  набора  поддерживаемых  типов
данных будет производиться засчет введения новых  подтипов  этих  изначально
определенных типов данных. В будущем добавление имен типов  верхнего  уровня
может быть произведено только при принятии новой версии стандарта MIME. Если
по  какой-либо  другой  причине  в    существующей    версии    используется
незарегестрированный тип содежимого, ему должно быть дано имя,  начинающееся
с "X-", чтобы подчеркнуть его нестандартный статус  и  заранее  предупредить
конфликт с официальным именем типа, которое может быть введено позднее. <p align="justify">

Правильное заполнение поля Content-Type:
<PRE>
     содержимое := "Content-Type"  ":"  тип  "/"  подтип  *(";" параметр)
                  ; нечувствительное к регистру букв задание типа и подтипа
     тип :=     "application"     / "audio"
              / "image"           / "message"
              / "multipart"       / "text"
              / "video"           / признак нестандартного типа
              ; Все значения нечувствительны к регистру букв
     признак нестандартного типа :=  x- / iana-
     iana- := &lt;общепринятый признак расширения, зарегистрированный соответ-
               ственно приложению "E" RFC 1521>
     x- := &lt;Два последовательных символа "X-" или "x-", без пробела
            или другого символа между ними>
     подтип := слово    ; регистр безразличен
     параметр := атрибут "=" значение
     атрибут := слово   ; регистр безразличен
     значение := слово / строка в кавычках
     слово := любые ASCII-символы кроме  пробелов,  Ctrl-последова-
     тельностей и специальных символов
     Специальные символы:=  "(" / ")" / "&lt;" / ">" / "@"
                         /  "," / ";" / ":" / "\" / &lt;">
                         /  "/" / "[" / "]" / "?" / "="
     ; Эти символы используются в строке значений параметров
</PRE>
<p align="justify">
Здесь набор специальных символов отличается от набора, определенного в  RFC
822 только наличием символов "/", "?", "=" и отсутствием символа ".".
<p align="justify">

Указание подтипа в данном поле является обязательным, т.к. нет  подтипов  по
умолчанию.  В  отличие  от  имен  типов,  подтипов  и  параметров,  значения
параметров в общем случае являются чувствительными к регистру букв, но могут
быть и нечувствительными - в зависимости от  параметра.  Например,  значения
границ multipart-письма являются чувствительными, а  значение  "access-type"
для message/External-body не является. <p align="justify">

Существует два приемлимых механизма для введения новых  подтипов  для  поля
Content-Type:
<p align="justify">
<OL>
    <LI> Нестандартные значения (начинающиеся с "X-") могут  быть  опредлены
          по договоренности для двух или  более  общающихся  друг  с  другом
          почтовых агентов (программ) без какой-либо внешней  регистрации  и
          стандартизации.

    <LI> Новые стандартные значения подтипов  должны  быть  документированы,
          зарегистрированы и опробованы в IANA, как описано в приложении "E"
          RFC  1521.  Если  новй   подтип    предлагается    для    широкого
          использования,  формат,  описываемый  им,  должен  быть  описан  в
          опубликованной   спецификации    и,    возможно,    предложен    к
          стандартизации.
</OL>
<p align="justify">
Семь предопределенных типов верхнего уровня,  более  детально,  представляют
собой следующее: <p align="justify">

    <STRONG>text</STRONG>  --  текстовая  информация.  Основой   подтип    -
          <STRONG>"plain"</STRONG>    -        соответствует        обычному
          неформатировнному тексту и не  требует  специального  программного
          обеспечения для отображения этого текста за исключением  поддержки
          национальных  кодировок.  Другие  подтипы  используются  в  случае
          размеченного текста, когда с помощью специальной  программы  можно
          улучшить его визуалзацию, но для понимания идеи  содержания  можно
          обойтись  и  без  дполнительного  ПО.  Возможные  подтипы    могут
          описывать легкочитаемые форматы различных текстовых процессоров.<p align="justify">

    <STRONG>multipart</STRONG> -- содержимое письма  состоит  из  некоторого
          множества частей, содержащих  данные  различных  взаимонезависимых
          типов. Изначально определено четыре подтипа:

          <OL>
          <LI><STRONG>"mixed"</STRONG> - основной;
          <LI><STRONG>"alternative"</STRONG> -  для  представления  одних  и
          тех же данных в разных форматах;
          <LI><STRONG>"parallel"</STRONG> - если  разные  части    документа
          должны просматриваться одновременно;
          <LI><STRONG>"digest"</STRONG> - если каждая из частей тела  письма
          имеет тип "message".
          </OL><p align="justify">

    <STRONG>message</STRONG> -- письмо в  письме.  Тело,  содержащее  данные
         типа "message", само является письмом или частью письма,  полностью
         отформатированного в соответствии со стандартом RFC 822, которое, в
         свою очередь,  может  содержать  свое  собственное  поле  заголовка
         "Content-Type".<BR>
         Подтипы:
         <OL>
         <LI><STRONG>"rfc822"</STRONG> - основной;
         <LI><STRONG>"partial"</STRONG> - определен для  частично-цитируемых
         писем для предотвращения фрагментирования тел содержащихся писем  в
         случае слишком большой их общей длины  для  возможностей  почтового
         транспорта;
         <LI><STRONG>"External-body"</STRONG> - используется, чтобы указать,
         что тело письма очень большое и находится вне письма.
         </OL><p align="justify">

    <STRONG>image</STRONG>  --  графические    данные.    Графика    требует
         соответствующего устройства вывода (графический  дисплей,  принтер,
         факс) для отображения своей информации. Изначально  определены  два
         подтипа для наиболее распространенных графических форматов - jpeg и
         gif.<p align="justify">

    <STRONG>audio</STRONG>  --  звуковая  информация.    Требует    звуковое
         устройство (динамик или наушники) для вывода  информации.  Основной
         подтип - <STRONG>"basic"</STRONG>.<p align="justify">

    <STRONG>video</STRONG>  --  видео.  Требует  специальных  аппаратных   и
         программных  возможностей   для    отображения    видео-информации.
         Единстванный    изначально      определенный        подтип        -
         <STRONG>"mpeg"</STRONG>.<p align="justify">

    <STRONG>application</STRONG> -- как правило, неинтерпретируемый двоичный
         код  либо  информация,  предназначенная  для  обработки    почтовой
         программой.<BR> Подтипы: <OL> <LI><STRONG>"octet-stream"</STRONG> -
         основной  подтип;  предназначен  для  неинтерпретируемых   двоичных
         данных, для которых рекомендуемым  действием  является  предложение
         пользователю    сохранить     в        файл        на        диске.
         <LI><STRONG>"PostScript"</STRONG>    -    дополнительный    подтип;
         применяется при  пересылке  PostScript-документов  в  теле  письма.
         </OL> <p align="justify">

По  умолчанию,  письма,  как  и  в  стандарте  RFC  822   пишутся    простым
(неразмеченным) текстом в языковой кодировке US-ASCII, что  по  спецификации
MIME может быть описано как  "Content-type:  text/plain;  charset=us-ascii".
Это значение полагается,  если  поле  Content-type  не  определено.  Поэтому
почтовая программа получателя может неверно истолковать  содержимое  письма,
если при отправке не было указано поле Content-type, но на самом деле  текст
письма имеет другую кодировку или даже тип.<p align="justify">

При  отсутствии  поля  Content-type  или  поля  MIME-Version  в    заголовке
MIME-письма нельзя быть точно уверенным, что письмо имеет языковую кодировку
именно US-ASCII, поскольку могут  еще  встречаться  почтовые  программы,  не
использующие соглашения MIME. Но хотя возможно, что письмо, не содержащее  в
заголовке полей  MIME-Version  и  Content-Type,  может  содержать  все,  что
угодно,  например,  юниксовский  tar-архив,  сжатый  gzip'ом  и  обработаный
uuencode, все же, создателям почтовых программ рекомендуется оставлять  этот
факт  без  внимания  и  ориентироваться  на  значение  по  умолчанию,   т.е.
"text/plain; charset=us-ascii".<p align="justify">

Необходимо  учесть,  что  в  будущем  ожидается  заметное  увеличение  числа
регистрированных типов и особенно подтипов содержимого писем. Если  почтовая
программа встретит неизвестное ей значение  поля  Content-type,  она  должна
интерпретировать  содержимое  этого  письма  как  "application/octet-stream"
(см.выше).

<a name=5></a>
<H3>5. Поле заголовка Content-Transfer-Encoding</H3>
<p align="justify">
   Многие типы  данных,  пересылаемых  через  email  требуют  "натурального"
представления, то есть, 8-битный набор символов либо двоичный код  (что  для
машины - одно и то же, только представимо для  пользователя  по-разному).  В
таком виде данные не могут быть пересланы по 7-битным  почтовым  протоколам,
например, RFC 821, который,  к  тому  же,  ограничивает  длину  строки  1000
символами. <p align="justify">

Стандартные  механизмы  конвертирования  почты  в  7-битный  короткострочный
формат,  приемлимый  для  почтового  транспорта,  описывает  поле  заголовка
Content-Transfer-Encoding. <p align="justify">

В  отличие  от  типов    содержимого,    увеличение    множества    значений
Content-Transfer-Encoding не является необходимым и  даже  нежелательно.  Но
установление единого механизма конвертирования не представляется  возможным.
Существует противоречие между желанием эффективно "ужать" бинарные данные  и
желанием  трансформировать  данные,  которые,  хотя  бы  частично   являются
7-битным текстом, так, чтобы их все-таки можно было читать. По этой  причине
необходимы по крайней мере 2 механизма конвертации: "читабельный" и  "плотно
ужимающий". <p align="justify">

Данное поле не было определено в предыдущих стандартах. Его значение  должно
быть строкой без пробелов, определяющей тип конвертации, как показано  ниже:
<PRE>
   конвертация := "Content-Transfer-Encoding" ":" механизм
   механизм :=     "7bit"  ;
                  / "quoted-printable"
                  / "base64"
                  / "8bit"
                  / "binary"
                  / x-token
</PRE>
<p align="justify">

Значения не чувствительны к регистру букв, то есть, Base64, BASE64 и bAsE64
- одно и то же. Значение "7BIT" означает, что тело письма уже имеет 7-битный
формат и не тренбует дополнительной обработки для пересылки  по  почте.  Это
значение    полагается    по    умолчанию,    если     поле        заголовка
Content-Transfer-Encoding отсутствует. <p align="justify">

Значения "8bit", "7bit"  и  "binary"  означают,  что  никакой  трансформации
содержимого не производится. Однако, они сделаны  различными  для  индикации
того, что из себя представляет содержимое письма, и, соответственно, способа
обработки, который может потребоваться для данной  транспортной  системы.  В
частности: <p align="justify">

       <STRONG>"7bit"</STRONG> означает, что данные являются текстом,  имеют
              короткие строки и языковую кодировку US-ASCII.<p align="justify">

       <STRONG>"8bit"</STRONG> означает короткие  строки,  но  в  них  могут
              содержаться не-ASCII символы (128-255).<p align="justify">

       <STRONG>"Binary"</STRONG> означает, что тело письма  может  содержать
              не-ASCII символы, но строки  могут  быть  произвольной  длины,
              т.е.  слишком  длинными  для    SMTP-транспорта,    и    может
              несоблюдаться соглашение  по  признаку  конца  строки  (CRLF),
              принятое в SMTP-транспорте. <p align="justify">

Хотя на первый взгляд разница в значениях  Content-Transfer-Encoding  может
показатся неважной - ведь все они  означают,  что  никакого  преобразования
нет, но четкая разметка важна для почтовых шлюзов между  разными  почтовыми
системами, имеющими разные возможности и особенности работы, число  которых
со временем растет.
<p align="justify">

Спецификация на почтовый транспорт  для  пересылки  некодированных  8-битных
данных дана в RFC-1426.  Однако,  нет  стандартизованных  транспортов  рочты
Internet,  для  которых  является  приемлимым  включение  в   тело    письма
некодированных двоичных данных. Таким образом, значение "binary"  фактически
не  является  легальным  в  Internet.  Но  в  соответствии  с   MIME,    при
использовании почтовой системой транспорта, умеющего  работать  с  двоичными
данными, в случае, когда  необходимо  послать  двоичные  данные  по  e-mail,
необходимо указать это в заголовке в поле Content-Transfer-Encoding. <p align="justify">

Пять значений, определенных для поля  Content-Transfer-Encoding,  ничего  не
говорят  о  типе  содержимого  кроме  указания  алгоритма  кодирования  либо
требований к почтовому транспорту в случае некодированных данных. <p align="justify">

Производители почтового ПО, если необходимо, могут определить новые значения
поля Content-Transfer-Encoding, но эти значения должны  иметь  префикс  "X-"
("x-"), чтобы подчеркнуть их нестандартный характер. Однако,  в  отличие  от
типов  и  подтипов    поля    Content-Type,    введение    новых    значений
Content-Transfer-Encoding  настоятельно  не  рекомендуется,  так  как  может
оказаться помехой для  взаимосовместимости  почтовых  систем.  Использование
X-значений  позволяется  только  как  результат    взаимосоглашения    между
взаимодействующими системами. <p align="justify">

Если поле Content-Transfer-Encoding появляеися  в  заголовке  тела  какой-то
части письма, оно применяется только к содержимому этой части.  Если  письмо
(часть  письма)  имеет  тип   "multipart"    или    "message",    то    поле
Content-Transfer-Encoding может иметь  в  качестве  своего  значения  только
длину символа ("7bit", "8bit" и т.д.) или "binary". <p align="justify">

Необходимо    заметить.    что      электронная        почта        является
символьно-ориентированной, так что механизмы конвертации работают с  данными
как с потоком символов, а не битов. Если битовый поток должен быть кодирован
посредством  какого-либо  из  этих  механизмов,  сначала  он  должен    быть
конвертирован в 8-битный поток байтов, используя порядок битов,  стандартный
для сетей (старшие разряды  в  конце).  То  есть,  передние  биты  в  потоке
становятся битами высшего порядка в байте. Если битовый  поток  оканчивается
неполным байтом, недостающие разряды заполняются нулями. <p align="justify">

Все кодирующие механизмы, определенные в спецификации MIME, кодируют  любые
данные в символьную форму. Так, к примеру, полагая, что тело письма  (части
письма) имеет поля заголовка вроде:
<p align="justify">
<PRE>
     Content-Type: text/plain; charset=ISO-8859-1
     Content-transfer-encoding: base64
</PRE>
<p align="justify">

то это  означает,  что  тело  письма  представляет  собой  ASCII-код  base64
текстовых  данных,  которые  в  нормальном  виде  имеют  языковую  кодировку
ISO-8859-1, и будут в этой языковой кодировке после декодирования. <p align="justify">

Все множество определенных  значений  поля  content-transfer-encoding  кроме
начинающихся  с  префикса  "X-",  зарезервировано  в  IANA   для    будущего
использования. Частные  соглашения  по  значениям  content-transfer-encoding
также настоятельно не рекомендуются. <p align="justify">

Некоторые значения Content-transfer-encoding могут использоваться  только  с
определенными  типами  (поле  Content-Type).    В    частности,    запрещено
использовать любые значения кроме  "7bit",  "8bit",  или  "binary"  с  любым
типом, рекурсивно включающим заголовки с полем  Content-Type  (как  правило,
это  типы  "multipart"  и  "message").  Все  кодирования,  необходимые   для
содержимого тел многочастного письма должны быть произведены на более низком
уровне. <p align="justify">

<H4>Замечания по ограничениям конвертации:</H4>

Необходимо  предотвращать  случаи  вложенного  кодирования,  когда    данные
проходят через алгоритм конвертации несколько раз и должны  столько  же  раз
быть декодированы, чтобы быть  читаемыми.  Вложенное  кодирование  добавляет
сложностей пользовательским почтовым программам: кроме очевидных  проблем  с
множественной конвертацией, они могут скрыть основную  структуру  письма.  В
частности,  они  могут  привести  к  тому,  что  несколько    операций    по
декодированию могут потребоваться только для того, чтобы определить, объекты
каких типов находятся в  письме.  Запрещение  вложенного  кодирования  может
осложнить работу некоторых почтовых шлюзов, но это будет  меньшей  проблемой
по сравнению с трудностями для пользовательских почтовых программ. <p align="justify">

<I>ЗАМЕЧАНИЕ ПО ПЕРЕВОДУ КОДОВ:</I>  Конверторы  quoted-printable  и  base64
разработаны так, что данные после их применения  легко  взаимоконвертируемы.
Единственный нюанс, возникающий в  подобной  ретрансляции  -  признак  конца
строки. При конвертации из quoted-printable в base64 перевод  строки  должен
быть заменен последовательностью CRLF. Соответственно и наоборот, но  ТОЛЬКО
при конвертации текстовых данных.

<a name=51></a>
<H4>5.1. Механизм конвертации "Quoted-Printable"</H4>
<p align="justify">
   Этот механизм предназначен для представления данных, в основном состоящих
из байтов, соответствующих символам, имеющим изображение в символьном наборе
ASCII.  В  результате  данного  кодирования  все  байты  будут  иметь  такие
значения, гарантированные от дальнейшей  модификации  почтовым  транспортом.
Если конвертируемые данные в основном  представляют  собой  ASCII-текст,  то
конечная их  форма  остается  узнаваемой  и  читаемой  для  человека.  Тело,
полностью состоящее из ASCII-символов, также может  быть  конвертироавано  в
Quoted-Printable,  что  гарантирует  его   содержимому    целостность    при
прохождении через всякие шлюзы, в которых происходит языковая  перекодировка
символов или преобразование концов строк и т.д. <p align="justify">

В  Quoted-Printable  байты  должны  быть  рпедставлены  в  соответствии   со
следующими правилами: <p align="justify">

<I>ПРАВИЛО #1:</I> (обычное 8-битное представление). Каждый байт, кроме тех,
которые используются для обозначения конца строки, может быть представлен  с
помощью двух шестнадцатиричных цифр, предворяемых знаком "=". При  написании
шестнадцатиричных цифр с A по F должны использоваться заглавные буквы. Кроме
тех  случаев,  когда  нижеследующие   правила    позволяют    альтернативное
кодирование, данное правило является обязательным. <p align="justify">

<I>ПРАВИЛО #2:</I> (Буквенное представление). Байты с десятичным значением с
33  по  60  и  с  62  по  126  МОГУТ  быть  представлены    ASCII-символами,
соответствующими этим значениям (с '!' по '<' и с '>' по '~'). <p align="justify">

<I>ПРАВИЛО #3:</I>  (Пробелы):  Байты  со  значениями  9  и  32  МОГУТ  быть

представлены как ASCII-символы "Табуляция" и "Пробел",  но  НЕ  ДОЛЖНЫ  быть
представлены  так  в  конце  строки.    Везде,    где    они    представлены
соответствующими ASCII-символами, за ними должен следовать  символ,  имеющий
графическое  изображение  (печатный  символ).  В  конце  же  строки  символы
табуляции и пробела должны быть представлены в соответствии с  правилом  #1,
так как некоторые почтовые транспорты могут убирать пробелы в конце  строки.
<p align="justify">

<I>ПРАВИЛО #4:</I> (Конец строки): Конец строки в тексте письма должен  быть
представлен (в соответствии с RFC 822) последовательностью CRLF. Так  как  в
каноническом  представлении  текста  не  требуется  визуального  отображения
символов конца строки, в Quoted-Printable не используется  видимых  символов
для обозначения  конца  строки.  Для  представления  бинарных  данных  более
предпочтительной является кодировка base64. <p align="justify">

Необходимо  заметить,  что  многие  реализации  почтовых   программ    могут
кодировать по-своему. В  частности,  при  представлеии  текста  в  системах,
использующих другие соглашения по  обозначению  конца  строки  (отличные  от
CRLF). Такие реализации недопустимы, и генерация концов строки  должна  быть
стандартизована везде, чтобы не требовалось  распознавать,  используется  ли
какое-либо альтернативное представление. <p align="justify">

<I>ПРАВИЛО #5:</I> (Мягкий конец строки): В соответствии с  Quoted-Printable
длина  строки  не  должна  превышать  76  символов.  В   противном    случае
используется  'мягкий'  перевод  строки,  представимый  знаком    равенства.
Например, если исходная строка имела вид:
<PRE>
     Now's the time for all folk to come to the aid of
     their country.
</PRE>
<p align="justify">
то в Quoted-Printable encoding он может быть представлена следующим образом:

<PRE>
     Now's the time =
     for all folk to come=
     to the aid of their country.
</PRE>
<p align="justify">
Это  обеспечивает  механизм    восстановления    исходной    длины    строки
пользовательским почтовыи агентом. <p align="justify">

Поскольку символ дефиса ("-") представляется в  Quoted-Printable  в  обычном
виде,  особую  осторожность  нужно  соблюдать  при   заключении    тела    в
Quoted-Printable в многочастное письмо, чтобы  удостовериться,  что  граница
этого включения не проявляется нигде внутри  этого  включения  (лучше  всего
выбрать обозначение границы в виде последовательности символов "=_", которая
никогда  не  появляется  в  теле,  закодированном  в  Quoted-Printable.  См.
определение многочастного письма далее.) <p align="justify">

<I>ЗАМЕЧАНИЕ:</I>  Quoted-Printable  представляет    собой    нечто    вроде
компромисса между  читабельностью  и  сохранностью  при  пересылке.  Тела  в
Quoted-Printable будут надежно  защищены  при  прохождении  многих  почтовых
шлюзов, но могут быть  не  очень  хорошо  переданы  через  некоторые  шлюзы,
использующие  трансляцию  в  EBCDIC.  (Теоретически,   EBCDIC-шлюз    должен
кодировать тело из quoted-printable в base64 и затем  декодировать  обратно,
но  таких  шлюзов  пока  не  существует).  Единственный    способ    добится
действительно надежной  транспортировки  через  EBCDIC-шлюз  -  экранировать
ASCII-символы
<PRE>
     !"#$@[\]^`{|}~
</PRE>
<p align="justify">
в соответствии с правилом #1.
<p align="justify">

Так как данные в quoted-printable являются  строчно-ориентированными,  можно
ожидать, что представление концов строки в Quoted-Printable  будет  изменено
почтовым транспортом таким же образом, как и обычный текст может  измениться
при пересылке по Internet-почте между системами с  разными  соглашениями  по
представлению  концов  строки.  Если  подобные  изменения  могут    нарушить
целостность данных, то имеет смысл  пользоваться  кодировкой  base64,  а  не
Quoted-Printable. <p align="justify">

Вниманию  создателей  ПО:    Если    двоичные    данные    пересылаются    в
Quoted-Printable, то надо соблюдать осторожность при кодировании символов CR
и LF. В частности, последовательность  CRLF  должна  быть  представлена  как
"=0D=0A", в противном случае, если CRLF означает конец строки, то она  может
быть неверно интерпретирована в платформах с другими соглашениями  по  концу
строки. <p align="justify">

Синтаксис данных в quoted-printable описывается следующим образом:
<p align="justify">
<PRE>
   quoted-printable := ([*(простой текст / ПРОБЕЛ / ТАБУЛЯЦИЯ) простой текст]
                        ["="] CRLF)
        ; Максимальная длина строки - 76 символов, включая CRLF
   простой текст := байт /&lt;любой ASCII-символ "=", ПРОБЕЛ или ТАБУЛЯЦИЯ>
        ; символы, не перечисленные в приложении B к RFC 1521 как  безопас-
        ; ные для почты, также не рекомендуются к использованию
   байт := "=" 2(ФИФРА / "A" / "B" / "C" / "D" / "E" / "F")
        ; байт используется для символов > 127, =, ПРОБЕЛ, или ТАБУЛЯЦИЯ,
        ; и рекомендуется для представления любых символов, не  перечислен-
        ; ных в приложении B к RFC 1521 как безопасные для почты
</PRE>
<a name=52></a>
<H4>5.2.  Механизм конвертации Base64</H4>
<p align="justify">

   Этот    алгоритм    разработан    для    представления       произвольных
последовательностей байтов в форму,  читаемую  для  человека.  Кодирующий  и
декодирующий алгоритмы очень просты, но закодированные  данные  примерно  на
33%  больше,  чем  некодированные.  этот  метод  идентичен  тому,    который
используется в приложениях PEM (Privacy Enhanced Mail), описанной в RFC 1421
с одним отличием: base64 не приемлит встроенного "чистого" текста. <p align="justify">

Base64 использует 65-символьный поднабор  из  US-ASCII,  выделяя  6  бит  на
каждый печатный  символ.  (65-й  символ  "="  используется  для  обозначения
функции спец. обработки). <p align="justify">

<I>ПРИМЕЧАНИЕ:</I> этот поднабор имеет важное свойство:  он  идентичен  всем
версиям языковой кодировки ISO 646, включая US ASCII, а также  всем  версиям
EBCDIC. Другие популярные механизмы кодирования (uuencode,  base85  -  часть
уровня 2 PostScript) не разделяют этих свойств и  поэтому  не  удовлетворяют
требованиям переносимости для двоичных данных электронной почты. <p align="justify">

Процесс кодирования преобразует 4 входных символа в виде  24-битной  группы,
обрабатывая их  слева  направо.  Эти  группы  затем  рассматриваются  как  4
соединенные 6-битные группы, каждая из  которых  транслируется  в  одиночную
цифру алфавита base64. При кодировании base64, входной поток  байтов  должен
быть упорядочен старшими битами вперед. <p align="justify">

Каждая 6-битная группа используется как индекс  для  массива  64-х  печатных
символов. Символ,  на  который  указывает  значение  индекса,  помещается  в
выходную  строку.  Эти  символы  выбраны  так,  чтобы   быть    универсально
представимыми  и  исключают  символы,  имеющие  специальное  значение    для
SMTP-транспорта (".", CR, LF) и для синтаксиса вложенных тел MIME ("-"). <p align="justify">
<PRE>
                        Таблица 1: Алфавит Base64
    Значение Код    Значение Код    Значение Код    Значение Код
           0 A            17 R            34 i            51 z
           1 B            18 S            35 j            52 0
           2 C            19 T            36 k            53 1
           3 D            20 U            37 l            54 2
           4 E            21 V            38 m            55 3
           5 F            22 W            39 n            56 4
           6 G            23 X            40 o            57 5
           7 H            24 Y            41 p            58 6
           8 I            25 Z            42 q            59 7
           9 J            26 a            43 r            60 8
          10 K            27 b            44 s            61 9
          11 L            28 c            45 t            62 +
          12 M            29 d            46 u            63 /
          13 N            30 e            47 v
          14 O            31 f            48 w            = (заполнитель)
          15 P            32 g            49 x
          16 Q            33 h            50 y
</PRE>
<p align="justify">
   Выходной поток (закодированные бфайты) должен иметь длину строк не  более
76 символов. Все признаки перевода строки и другие символы, отсутствующие  в
таблице 1, должны быть проигнорированы  декодером  base64.  Среди  данных  в
Base64 символы, не перечисленные в табл. 1, переводы строки  и  т.п.  должны
говорить об ошибке передачи данных, и,  соответственно,  почтовая  программа
должна оповестить пользователя о ней. <p align="justify">

Если в хвосте потока кодируемых данных осталось меньше, чем 24 бита,  справа
добавляются нулевые биты до образования целого числа 6-битных  групп.  А  до
конца 24-битной группы остается от 0  до  3-х  недостающих  6-битных  групп,
вместо каждой из которых ставится  символ-заполнитель  '='.  Поскольку  весь
входной поток представляет собой целое число 8-битных  групп  (т.е.,  просто
байтных значений), то возможны лишь следующие случаи: (1) входной поток  как
раз оканчивается 24-битной группой. В таком  случае,  выходной  поток  будет
оканчиваться четырьмя символами Base64 без символа '='; (2)  хвост  входного
потока имеет длину 8 бит. Тогда в конце выходного  кода  быдут  два  символа
Base64, с добавлением двух символов '='; (3)  хвост  входного  потока  имеет
длину 16 бит. Тогда в конце выходного будут стоять три символа Base64 и один
символ '='. <p align="justify">

Т.к. символ '=' является хвостовым заполнителем, его появление в теле письма
может означать только то, что конец данных достигнут. Но такой гарантии нет,
если число переданных битов кратно 24. <p align="justify">

Любые бессмысленные последовательности в коде Base64 вроде  "====="  должны
быть игнорированы.
<p align="justify">

Если  кодируемый  текст  не  находится  в  канонической  форме.  то    перед
конвертацией  в  Base64  необходимо  сначала  все  концы   строк    заменить
стандартной последовательностью CRLF. Предпочтительнее эту функцию  встроить
в  кодировщик  Base64,   нежели    заставлять    пользователя    производить
предварительную канонизацию текста другими средствами. <p align="justify">

Нет нужды экранировать вложенные тела внутри многочастного тела (multipart)
при кодировании его в Base64, так как в коде Base64 отсутствует символ '-'.
<a name=6></a>
<H3>6.  Дополнительные Content- поля заголовка</H3>
<a name=61></a>
<H4>6.1.  Необязательное поле Content-ID</H4>

   При создании почтового  агента  верхнего  уровня  может  быть  желательно
позволить одному телу иметь ссылку на другое.  Для  этого  поля  могут  быть
помечены с помощью поля заголовка  "Content-ID",  синтаксически  идентичного
полю "Message-ID":
<PRE>
     идентификатор :=  "Content-ID" ":" идентификатор письма
</PRE>
<p align="justify">
   Как и значения поля Message-ID, значения  поля  Content-ID  должны  быть
абсолютно уникальными (для всего мира).
<p align="justify">

Такой идентификатор может быть использован  для  идентификации  тела  письма
(части письма) в нескольких контекстах, в часности, для кэширования  данных,
указываемых с помощью механизма message/external-body. Хотя поле  Content-ID
является необязательным в  общем  случае,  его  использование  необходимо  в
реализациях,    генерирующих    данные,    имеющие    дополнительный     тип
"message/external-body" (поле Content-type). Каждое тело такого типа  должно
обязательно иметь в своем заголовке поле Content-ID для  обеспечения  ссылки
на такие данные. <p align="justify">

Значение  поля  Content-ID  имеет  специальную  семантику  в  случае   типа
multipart/alternative. (См. соотв. пункт).
<a name=62></a>
<H4>6.2.  Необязательное поле Content-Description</H4>
<p align="justify">

   Возможность ассоциировать некоторую  описательную  информацию  с  данными
часто  очень  желательна.  например,  может  быть  полезным  описать   тело,
содержащее графическое изображение, как "a  picture  of  the  Space  Shuttle
Endeavor."  Этот  текст  и  может  быть    помещен    в    поле    заголовка
Content-Description.
<PRE>
     описание := "Content-Description" ":" *текст
</PRE>
<p align="justify">
   Описание  должно  иметь  языковую  кодировку  US-ASCII,  хотя   механизм,
определенный в RFC-1522 может быть использован для не-US-ASCII значений.
<a name=7></a>
<H3>7. Предопределенные значения  поля  Content-Type</H3>
<a name=71></a>
<H4>7.1  Тип 'Text'</H4> <p align="justify">

   Тип 'text' предназначен для пересылки текстовых материалов. Это  значение
поля - по умолчанию. Для обозначения языковой кодировки текста  используется
параметр  "charset"  для  некоторых  подтипов,  включая  основной    подтип,
"text/plain",  соответствующий  простому  (неформатированному)  тексту.    В
Internet'овской  почте  значением  Content-Type  по    умолчанию    является
следующее: "text/plain; charset=us-ascii". Если текст является размеченным и
нет соответствующего ПО  для  корректного  визуального  представления  этого
текста пользователю, имеет смысл сообщить ему подтип этих текстовых  данных.
<a name=711></a>
<H5>7.1.1.  Параметр 'charset'</H5>
<p align="justify">
В  отличие  от  других  значений,  значения  этого  параметра  не   являются
чувствительными к регистру букв. <p align="justify">

Спецификации любых новых подтипов типа 'text' должны  определять,  будет  ли
этот новый подтип  использовать  параметр  "charset"  либо  наоборот,  будет
запрещать его использование. Любое тело, не содержащее внутри  себя  других,
должно целиеом быть в одной языковой кодировке. В частности, создатели новых
подтипов должны уделить внимание многбайтным символьным наборам. <p align="justify">

Дополнительно  к  предопределенным  новые  языковые  кодировки  могут   быть
зарегистрированы через IANA, хотя стандартизация  их  использования  требует
опробирования IESG  (см.  RFC-1340).  Если  используется  8-битная  языковая
кодировка (например, koi8 или cp866), то необходимо наличие  поля  заголовка
Content-Transfer-Encoding для обеспечения передачи через ряд  протоколов,  в
частности, SMTP. <p align="justify">

Необходимо заметить, что управляющие символы (0-31, 127),  включая  DEL,  не
имеют определенного значения за исключением последовательности CRLF (13,10),
означающей конец строки. Два символа де-факто широко употребляются: FormFeed
(12), означающий, что следующий за ним  текст  должен  начинаться  на  новой
странице; и TAB (9), часто, но не всегда  означающий  "перевести  курсор  на
следующий ближайший столбец после данной позиции, где номер  столбца  кратен
воьсми". Любое другое использование управляющих  символов  или  DEL  в  теле
должно быть в рамках частного соглашения между отправителем  и  получателем.
Но такие соглашения крайне не рекомендуются и  по  возможности  должны  быть
заменены другими возможностями MIME. <p align="justify">

Существует  огромное  количество  языковых  кодировок,  что   не    является
положительным  фактом.  В  дальнейшем  предполагается  ввести  универсальную
многобитную языковую кодировку, поддерживающую все языки мира. К  сожалению,
существующая  практика  говорит  о  том,  что  возможно,  еще  долгое  время
электронной почте придется иметь дело с многими кодировками. По этой причине
предопределены имена для наиболее распространенных языковых кодировок:

<p align="justify">
<UL>
   <LI><I>US-ASCII</I>

   <LI><I>ISO-8859-X</I> -- где "X" - цифра от 1 до 9 включительно,  означающая  номер
             версии кодировки ISO-8859
</UL>
<p align="justify">
Параметр "charset"  был  определен  в  основном  для  текстовых  данных,  но
возможно, для бинарных данных  тоже  может  потребоваться  указать  языковую
кодировку, в этом случае  должен  использоваться  тот  же  синтаксис  те  же
значения. <p align="justify">

Почтовое  программное  обеспечение  должно    руководствоваться    принципом
наименьшего  набора  символов,  то  есть,  если  письмо  пишется  как-бы   в
восьмибитной ISO-8859-1, но в письме используются  символы  лишь  некоторого
поднабора, например, семибитного  US-ASCII,  то  почтовая  программа  должна
автоматически определить имя  символьной  кодировки  как  US-ASCII.  В  этом
случае уменьшится нагрузка в сети и увеличаися шансы, что получатель прочтет
письмо без искажений.

<a name=712></a>
<H5>7.1.2.  Подтип 'Text/plain'</H5>
<p align="justify">

   Это  основной  подтип,  соответствующий  простому    (неформатированному)
   тексту. Значение поля Content-Type для  почты  Internet  по  умолчанию  -
   "text/plain; charset=us-ascii". Это тип данных, соответствующий RFC 822.

<p align="justify">
   Других предопределенных подтипов для типа 'text' нет.
<p align="justify">
   Формальный синтаксис для типа 'text':
<PRE>
     тип := "text" "/" подтип [";" "charset" "=" имя языковой кодировки]
     подтип := "plain" / расширение (не предопределенный подтип)
     имя языковой кодировки:= "us-ascii"/ "iso-8859-1"/ "iso-8859-2"
            / "iso-8859-3" / "iso-8859-4"/ "iso-8859-5"/ "iso-8859-6"
            / "iso-8859-7" / "iso-8859-8" / "iso-8859-9" / расширение
            (не предопределенная кодировка)
</PRE>
<a name=72></a>
<H4>7.2.  Тип 'multipart'</H4>
<p align="justify">
Этот  тип  используется,  если  один  или  более  различных  наборов  данных
заключены в одном письме. Каждая часть тела должна иметь синтакс письма  RFC
822 (то есть, иметь заголовок,ь пустую  строку  и  тело),  но  должна  иметь
открывающую и закрывающую границы. <p align="justify">

Часть письма не должна интерпретироваться  как  настоящее  письмо  RFC  822.
Вообще, для части письма наличие заголовка не обязательно, так что она может
начинаться и с пустой строки, но  при  этом,  все  признаки,  описываемые  в
заголовке, имеют значение по умолчанию. Для частей письма имеют смысл только
поля, описывающие содержимое,  то  есть.  начтинающиеся  с  "Content-".  Все
остальные поля, необходимые в заголовке верхнего уровня, обычно игнорируются
в частях письма при обработке почты, более того, в некоторых почтовых шлюзах
они могут быть просто удалены. Для экспериментальных и частных  целей  могут
использоваться "X-" поля,  но  информация,  в  них  заложенная,  может  быть
потеряна при прохождении некоторых почтовых шлюзов. <p align="justify">

<I>ЗАМЕЧАНИЕ:</I> Различие между  письмом  RFC  822  и  частью  письма  MIME
является маленькой, но важной. Шлюз между почтой Internet и X.400, например,
должен иметь  возможность  отличить  часть  письма,  содержащую  графическое
изображение, от части письма, содежащей  вложенное  письмо,  телом  которого
является   графическое    изображение.    Для    представления    последнего
соответствующая часть письма должна иметь "Content-Type: message" и ее  тело
после пустой строки должно являться вложенным письмом со  своим  собственным
полем заголовка  "Content-Type:  image".  Схожесть  синтаксиса  обеспечивает
легкость конверсии от письма к части письма, но различие между  ними  должно
быть усвоено производителями ПО. <p align="justify">

Граница части письма не должна появляться внутри самой части письма.
<p align="justify">

Все существующие и будущие подтипы типа "multipart" должны иметь  идентичный
синтаксис.  Они  могут  различаться  своей  семантикой.    Это    требование
гарантирует, что совместимые пользовательские агенты смогут по крайней  мере
распознать и разделить части многочастного письма, даже имеющего неизвестный
им подтип. <p align="justify">

Как упомянуто в определении  поля  Content-Transfer-Encoding,  использование
других значений  кроме  "7bit",  "8bit"  или  "binary"  запрещено  для  типа
"multipart". Почтовые шлюзы и другие почтовые агенты часто вносят  изменения
в заголовки верхнего уровня. В  частности,  они  могут  добавлять,  убирать,
переупорядочивать  определенные  поля.  Такие  изменения    запрещены    для
заголовков частей письма, находяшихся внутри тела типа "multipart".
<a name=721></a>
<H5>7.2.1.     Multipart:  общий синтаксис</H5>
<p align="justify">
Поле  Content-Type  многочастного  письма   требует    одного    параметра,
"boundary", который определяет границы вложения. Границей является  строка,
состоящая из двух символов "-" (десятичный код  45)  и  значения  параметра
'boundary' из поля заголовка Content-Type.
<p align="justify">

<I>ЗАМЕЧАНИЕ:</I> Два символа "-" используются  для  совместимости  с  более
ранним методом вложения писем, описанным в RFC 934 и для  облегчения  поиска
границ. Однако, многочастные письма MIME не полностью совместимы с RFC  934;
в частности, они не подчиняются соглашению RFC 934  по  экранированию  строк
символом "-", так как с  каждым  новым  уровнем  экранирования  длина  строк
увеличивается. А поскольку SMTP-транспорты часто  обрезают  длинные  строки,
этот механизм становится  неприменимым  в  случае  многоуровневой  структуры
письма типа 'multipart'. <p align="justify">

<I>ВНИМАНИЮ ПРОИЗВОДИТЕЛЕЙ ПО:</I> синтаксис  параметров  поля  Content-Type
таков, что  зачастую  необходимо  значения  границ  в  параметре  'boundary'
заключать в кавычки. Это  не  всегда  требуется,  но  никогда  не  повредит.
Программистам следует изучить  синтаксис  внимательно,  чтобы  не  допустить
ошибок в поле Content-Type. Типичное поле Content-Type для типа  'multipart'
может выглядеть следующим образом:
<PRE>
     Content-Type: multipart/mixed;
          boundary=gc0p4Jq0M2Yt08jU534c0p
</PRE>
<p align="justify">
Но в следующем примере содержится ошибка:
<PRE>
     Content-Type: multipart/mixed;
          boundary=gc0p4Jq0M:2Yt08jU534c0p
</PRE>
<p align="justify">
(из-за двоеточия), которая может быть исправлена следующим образом:
<PRE>
     Content-Type: multipart/mixed;
          boundary="gc0p4Jq0M:2Yt08jU534c0p"
</PRE>
<p align="justify">

Это означает, что тело  письма  состоит  из  нескольких  частей,  каждая  из
которых соответствует синтаксису письма RFC 822, за  исключением  того.  что
область заголовка может быть абсолютно пустой  и  начальная  граница  каждой
части отмечена последовательностью:

<PRE>
     --gc0p4Jq0M:2Yt08jU534c0p
</PRE>
<p align="justify">

Нужно обратить внимание, что метка границы части письма должна располагаться
в начале строки, то есть, сразу же после признака конца строки CRLF. Причем,
последовательность CRLF полагается элементом метки границы, а  не  последним
элементом тела  предыдущей  части  (так  как  тело  предыдущей  части  может
неоканчиваться концом строки, что  принципиально  важно  в  случае  бинарных
данных. Если же тело предыдущей части оканчивается концом строки,  то  метке
границы соответственно должны предшествовать два  конца  строки).  Сразу  за
меткой границы должен следовать конец  строки  (CRLF),  или  при  отсутствии
заголовка следующей части письма, два конца строки. <p align="justify">

Метка границы не должна  иметь  длину  более  70  символов,  не  считая  два
начальных дефиса. <p align="justify">

Метка границы, следующая за последней частью письма, должна  отличаться  от
предыдущих меток, чтобы показать,  что  далее  не  последует  другой  части
письма. Отличие последней метки состоит в добавлении двух дефисов в конец:
<PRE>
     --gc0p4Jq0M2Yt08jU534c0p--
</PRE>
<p align="justify">

Обычно оставляется пространство для дополнительной информации  перед  первой
меткой границы и после последней. Обычно его  следует  оставлять  пустым,  и
обработчики  почты  должны  игнорировать  все,  что  в  этом    пространстве
содержится. <p align="justify">

<I>ЗАМЕЧАНИЕ:</I> Эти области приамбулы и  эпилога  обычно  не  используются
из-за отсутствия точной семантики  для  обработки  этих  областей  почтовыми
шлюзами, однако, многие программные MIME-продукты считают  удобным  помещать
туда  пояснительную  информацию  для   получателей,    которые    пользуются
до-MIME'овским  ПО.  По  этой  причине,  MIME-совместимые  программы  должны
игнорировать эти области. <p align="justify">

<I>ЗАМЕЧАНИЕ:</I> Поскольку метки границы не должны  появляться  внутри  тел
частей письма, почтовая программа, создающая письмо, должна иметь  алгоритм,
позволяющий  автоматически  подобрать  уникальную  последовательность,    не
встречающуюся  в  теле  ни  одной  из  частей,  либо  имеющую    минимальную
вероятность появления, если данные предварительно не сканируются на  наличие
таковой. <p align="justify">

В качестве простого примера предлагается двухчастное  письмо,  вторая  часть
которого оканчивается признаком конца строки, а первая нет:

<PRE>
      From: Nathaniel Borenstein <nsb@bellcore.com>
      To:  Ned Freed <ned@innosoft.com>
      Subject: Sample message
      MIME-Version: 1.0
      Content-type: multipart/mixed; boundary="simple boundary"
      Это приамбула. Должна быть игнорирована
      --simple boundary
      Это простой ASCII-текст.
      Он НЕ оканчивается признаком конца строки.
      --simple boundary
      Content-type: text/plain; charset=us-ascii
      Это простой ASCII-текст.
      Он оканчивается признаком конца строки.
      --simple boundary--
      Это эпилог. Тоже должен игнорироваться MIME-программами.
</PRE>
<p align="justify">

Часть письма, в свою очередь, также может иметь тип  'multipart',  то  есть.
быть многочастным телом, но при этом метки границ, использующиеся во внешнем
и во внутреннем multipart-телах, должны отличаться друг от друга. <p align="justify">

Использование типа 'multipart' в одночастном письме может  быть  полезно  в
некоторых контекстах и не запрещено.
<p align="justify">

Единственным обязательным параметром для типа 'multipart' является  параметр
'boundary', состоящий из 1-70 символов без хвостовых пробелов (которые могут
быть удалены в процессе пересылки, и тогда почтовая программа получателя  не
сможет разделить вложенные части).

<PRE>
   граница := 0*69&lt;символов границы> символ_границы_кроме_пробела
   символ границы := символ_границы_кроме_пробела / " "
   символ_границы_кроме_пробела := ЦИФРА / БУКВА ЛАТИНСКОГО АЛФАВИТА / "'"
                 / "(" / ")" / "+" /"_" / "," / "-"
                 / "." / "/" / ":" / "=" / "?"
</PRE>
<p align="justify">
Общий вид многочастного тела - следующий:
<PRE>
   многочастное тело := приамбула  вложения  признак_конца  эпилог
   вложение := разделитель  часть_тела  CRLF
   разделитель := "--"  метка_границы  CRLF
                  ; метка границы должна браться из поля Content-Type.
                  ; Не должно быть пробелов между "--" и меткой границы.
   признак конца := "--"  метка_границы  "--"  CRLF
                  ; Опять, без пробела перед "--",
   приамбула := игнорируемый текст
   эпилог := игнорируемый текст
   игнорируемый текст := *(*текст CRLF)
   часть_тела := &lt;письмо RFC 822, со всеми необязательными полями
                 заголовка>
</PRE>
<p align="justify">
<I>ЗАМЕЧАННИЕ:</I> В некоторых транспортах такие ограничения  RFC  822,  как
использование тольеко  печатных  символов  в  теле,  могут  не  действовать.
Ослабления  таких  ограничений  должны  быть  истолкованы   как    локальные
расширения определения тела письма настолько, насколько  они  поддерживаются
почтовым  транспортом  и  адекватно  документированы  в    поле    заголовка
Content-Transfer-Encoding. Однако, ни при каких обстоятельствах в заголовках
как письма, так и его частей, не  должно  содержаться  каких-либо  символов,
кроме US-ASCII.

<a name=722></a>
<H5>7.2.2.     Основной подтип "multipart/mixed"</H5>
<p align="justify">

Это основной подтип для типа 'multipart', он предназначен для случая,  когда
части письма взаимонезависимы. Любые  новые  подтипы,  неизвестные  почтовой
программе, должны быть истолкованы аналогично подтипу 'mixed'.

<a name=723></a>
<H5>7.2.3.     Подтип "multipart/alternative"</H5>
<p align="justify">

Этот подтип синтаксически идентичен предыдущему, но имеет несколько  другую
семантику.
<p align="justify">

Почтовые  системы  должны  распознавать,  что  данные  из   разных    частей
взаимозаменяемы. Системы должны  выбрать  наиболее  подходящий  вариант  для
локальной платформы и  других  условий,  в  некоторых  случаях,  с  согласия
пользователя.  Как  и  в  предыдущем  случае,  порядок  частей   в    письме
существенен. В этом случае альтернативы располагаются в  порядке  уменьшения
отличия от оригинала. Обычно, выбирается последняя часть  (альтернатива)  из
тех, которые имеют тип, поддерживаемый локальной системой получателя. <p align="justify">

Multipart/alternative может быть использована,  к  примеру,  для  пересылки
текста в некотором гипотетическом формате:
<PRE>
   From:  Nathaniel Borenstein &lt;nsb@bellcore.com>
   To: Ned Freed &lt;ned@innosoft.com>
   Subject: Formatted text mail
   MIME-Version: 1.0
   Content-Type: multipart/alternative; boundary=boundary42
   --boundary42
   Content-Type: text/plain; charset=us-ascii
      ... Здесь содержится версия простым текстом ....
   --boundary42
   Content-Type: text/richtext
      .... Здесь содержится версия с разметкой RFC 1341 ...
   --boundary42
   Content-Type: text/x-whatever
      .... Здесь содержится версия в гипотетическом формате ...
   --boundary42--
</PRE>
<p align="justify">
В этом  примере  пользователь,  чья  система  понимает  этот  гипотетический
формат, увидят именно эту версию, в то  время  как  остальные  будут  видеть
размеченный либо простой текст в зависимости от возможностей их системы. <p align="justify">

Обычно пользовательский агент,  создающий  письмо  в  multipart/alternative,
должны  располагать    альтернативные    части    в    порядке    увеличения
предпочтительности формата, то есть,  предполагая,  что  наш  гипотетический
формат является самым удобным для конкретных данных (иначе зачем было бы его
изобретать?),  пользовательский  агент  должен  располагать  альтернативу  в
простейшем формате первой, а самую размеченную последней.  Агент  получателя
должен отобразить последнюю из понимаемых им  альтернатив.  В  случае,  если
одна  из  альтернатив  сама  имеет  тип  'multipart'  и  содержит   подчасти
неизвестных типов, пользовательский агент может выбрать, показывать  ли  эту
альтернативу, предыдущую или обе. <p align="justify">

<I>ЗАМЕЧАНИЕ:</I>  С  точки  зрения  программиста,  может  показаться  более
удобным располагать альтернативы  в  обратном  порядке,  но  данный  порядок
позволяет устаревшим не-MIME'овским почтовым программам отобразить в  первую
очередь наиболее понятный вариант. <p align="justify">

ЗАМЕЧАНИЕ ПО СЕМАНТИКЕ ПОЛЯ  'CONTENT-ID'  В  ПИСЬМЕ  MULTIPART/ALTERNATIVE:
Рекомендуется, чтобы каждая часть имела уникальное значение поля  Content-ID
в случае, если содержимое этих частей не является идентичным.  Однако,  там,
где содержащаяся информация идентична (например, если несколько частей  типа
"application/external- body" определяют альтернативные пути доступа к  одним
и тем же внешним по отношению к письму данным), должно использоваться одно и
то же значение Content-ID, чтобы оптимизировать работу кэширующего механизма
на системе получателя. Однако, не рекомендуется, чтобы значения  Content-ID,
использующиеся  для   частей,    отличались    от    значения    Content-ID,
использующегося  в  заголовке  верхнего  уровня,  если  такое  поле  в   нем
присутствует.

<a name=724></a>
<H5>7.2.4.     Подтип "multipart/digest"</H5>
<p align="justify">
Этот подтип идентичен подтипу 'multipart/mixed', но имеет другую семантику.
Например, для 'digest' значением по умолчанию является не "text/plane", а
"message/rfc822".
<p align="justify">

В соответствии с этим подтипом, письмо-дайджест может выглядеть следующим
образом:
<PRE>
   From: Moderator-Address
   To: Recipient-List
   MIME-Version: 1.0
   Subject:  Internet Digest, volume 42
   Content-Type: multipart/digest;
        boundary="---- next message ----"
   ------ next message ----
   From: someone-else
   Subject: my opinion
      ... тело вложенного письма ...
   ------ next message ----
   From: someone-else-again
   Subject: my different opinion
      ... тело другого вложенного письма ...
   ------ next message ------
</PRE>
<a name=725></a>
<H5>7.2.5.   Подтип "multipart/parallel"</H5>
<p align="justify">

Отличие этого подтипа от "multipart/mixed", в частности, состоит в том,
что порядок расположения частей письма не принципиален.
<p align="justify">

Данные  этого  подтипа  должны  отображаться  одновременно,  если  платформа
получателя обладает соответствующими возможностями. Однако,  почтовый  агент
отправителя должен  сознавать,  что  программа  получателя  может  не  иметь
подобных возможностей и отобразить все части письма последовательно.

<a name=726></a>
<H5>7.2.6.     Другие подтипы типа "multipart"</H5>
<p align="justify">

В будущем ожидается введение новых  подтипов.  Программистам  рекомендуется
интерпретировать  незнакомые   подтипы    типа    'multipart'    аналогично
"multipart/mixed".
<p align="justify">
Формальный синтаксис поля Content-Type для данных типа  "multipart":
<PRE>
   multipart-тип := "multipart" "/" multipart-подтип
                    ";" "boundary" "=" метка_границы
   multipart-подтип := "mixed" / "parallel" / "digest"
                  / "alternative" / подтип-расширение
</PRE>
<H5>Полный пример Multipart-письма</H5>
<p align="justify">
Данный пример иллюстрирует письмо из пяти частей: две - простой текст,  одна
- вложенное multipart-письмо, одна - размеченный текст и  одна  -  вложенное
письмо, содержащее текст в  не-US-ASCII  языковой  кодировке.  Третья  часть
(вложенное multipart-письмо) состоит из двух частей, требующих параллельного
представления пользователю, - графическое изображение и звуковой фрагмент.

<PRE>
      MIME-Version: 1.0
      From: Nathaniel Borenstein &lt;nsb@bellcore.com>
      To: Ned Freed &lt;ned@innosoft.com>
      Subject: A multipart example
      Content-Type: multipart/mixed;
           boundary=unique-boundary-1
      Это область преамбулы multipart-письма. Почтовые программы, понимающие
      формат multipart, должны игнорировать все, что в ней  находится.  Если
      же вы при получении подобного письма видите этот текст на экране,  вам
      следует сменить почтовую программу.
      --unique-boundary-1
         ...Здесь находится некоторый текст...
      [Обратите внимание, что предшествующая  пустая  строка  означает,  что
      поля заголовка не были заданы,  и  это  -  простой  текст  в  языковой
      кодировке US ASCII.]
      --unique-boundary-1
      Content-type: text/plain; charset=US-ASCII
      Это  часть  предыдущей  части,  но  иллюстрирующая   ясную,    а    не
      подразумеваемую типизацию содержимого.
      --unique-boundary-1
      Content-Type: multipart/parallel;
           boundary=unique-boundary-2
      --unique-boundary-2
      Content-Type: audio/basic
      Content-Transfer-Encoding: base64
         ... кодированный в base64 одноканальный звуковой фрагмент для час-
             тоты 8000 Hz в формате mu-law....
      --unique-boundary-2
      Content-Type: image/gif
      Content-Transfer-Encoding: base64
         ... здесь  находится    кодированное    в    base64    графическое
             изображение....
      --unique-boundary-2--
      --unique-boundary-1
      Content-type: text/richtext
      Это &lt;bold>&lt;italic>текст с разметкой&lt;/italic>&lt;/bold>
      &lt;smaller>в соответствии с определением RFC 1341&lt;/smaller>
      &lt;nl>&lt;nl>Неправда ли, &lt;bigger>&lt;bigger>он крут?&lt;/bigger>&lt;/bigger>
      --unique-boundary-1
      Content-Type: message/rfc822
      From: (имя отправителя в US-ASCII)
      To: (адрес в US-ASCII)
      Subject: (subject в US-ASCII)
      Content-Type: Text/plain; charset=ISO-8859-1
      Content-Transfer-Encoding: Quoted-printable
         ... Некоторый текст в ISO-8859-1 ...
      --unique-boundary-1--
</PRE>
<a name=73></a>
<H4>7.3.  Тип 'message'</H4>
<p align="justify">
При пересылке почты часто возникает необходимость  включить  внутрь  письма
другое письмо. Для этого и используется тип 'message'.
<p align="justify">

Основной подтип - "rfc822" - не  требует  параметров  в  поле  Content-Type.
Дополнительные подтипы - "partial" и "External-body" - предполагают  наличие
параметров. <p align="justify">

<I>ЗАМЕЧАНИЕ:</I> Для перенаправляемой и возвращаемой почты  можно  было  бы
определить отдельные подтипы, однако, такая  почта  может  пересылаться  как
multipart-письмо, в котором первая часть  содержит  некоторую  пояснительную
текстовую информацию,  а  другая,  имеющая  тип  'message/rfc822',  содержит
перенаправляемое/возвращаемое        письмо.        Подобный          способ
перенаправления/возвращения почты сохраняет информацию о типе  оригинального
письма и позволяет ему быть корректно представленным получателю,  и  поэтому
настоятельно рекомендуется.

<a name=731></a>
<H5>7.3.1.  Основной подтип 'message/rfc822'</H5>
<p align="justify">
Этот подтип указывает, что тело письма содержит вложенное письмо в стандарте
RFC 822, однако, в отличие от заголовка RFC 822 верхнего уровня, для  каждой
части, являющейся письмом  RFC  822,  не  требуется  наличия  полей  "From",
"Subject" и, по крайней мере, одного поля "To". <p align="justify">

Не  смотря  на  использование  числа   "822",    тело,    имеющее    подтип
'message/rfc822', может включать дополнительную информацию  в  соответствии
со стандартом MIME. Другими словами,  письмо  'message/rfc822'  может  быть
MIME-письмом.
<a name=732></a>
<H5>7.3.2.    Подтип 'message/partial'</H5>
<p align="justify">

Этот подтип  определен  с  целью  обеспечения  возможности  пересылки  очень
больших  объектов  в  виде  нескольких  раздельных   частей,    автоматичски
"склеиваемых"  почтовой  программой  получателя.   Этот    механизм    может
пригодиться, когда промежуточные почтовые шлюзы ограничивают  индивидуальный
размер пересылаемых писем. Т.о., этот  подтип  говорит  о  том,  что  письмо
содержит лишь часть большого послания. <p align="justify">

Для этого подтипа необходимо указание трех параметров:
<p align="justify">
<OL>
   <LI><STRONG>"id"</STRONG> - уникальный идентификатор, позволяющий обнаружить остальные  части
   послания.
   <LI><STRONG>"number"</STRONG> - целое число, означающее номер части послания.
   <LI><STRONG>"total"</STRONG> - целое число, означающее  общее  количество
   частей.  Требуется  лишь  в  последней  части  и  не  обязателен    (хотя
   рекомендуется) для предыдущих частей. Эти  параметры  могут  следовать  в
   произвольном порядке.
</OL>
<p align="justify">
Пример: часть 2 3-х частного послания имеет следующие варианты заголовка:
<PRE>
                Content-Type: Message/Partial;
                     number=2; total=3;
                     id="oc=jpbe0M2Yt4s@thumper.bellcore.com"
                Content-Type: Message/Partial;
                     id="oc=jpbe0M2Yt4s@thumper.bellcore.com";
                     number=2
</PRE>
<p align="justify">
Но часть 3 обязательно должна содержать параметр "total":
<PRE>
                Content-Type: Message/Partial;
                     number=3; total=3;
                     id="oc=jpbe0M2Yt4s@thumper.bellcore.com"
</PRE>
<p align="justify">
Необходимо заметить, что нумирация частей начинается с 1, а не с 0.
<p align="justify">

Когда подобным образом разбитые части собираются вместе, они образуют полное
MIME-письмо,  содержимое  которого  может  иметь  любой  другой    тип    и,
соответственно, свое поле заголовка Content-Type, описывающее этот тип. <p align="justify">

Семантика  partial-письма  должна  быть  та  же,  как  в  обычном  письме  с
содержимым данного типа, а не как в письме, содержащем "внутреннее"  письмо.
Это позволяет, например, переслать большой аудио-файл ввиде нескольких более
мелких,  остающихся,  тем  не  менее,  видимыми  получателю   как    обычные
аудио-письма, а не как вложенные аудио-письма. <p align="justify">

При "сборке" таких посланий в пункте назначения должны учитываться следующие
правила: <p align="justify">

<STRONG>(1)</STRONG> Все  поля  заголовка  части  1,  кроме  начинающихся  с
"Content-" и специальных "Message-ID", "Encrypted" и  "MIME-Version"  должны
быть скопированы в заголовок нового (общего) письма. <p align="justify">

<STRONG>(2)</STRONG> Только поля заголовка ВЛОЖЕННОГО письма, начинающиеся с
"Content-", а также поля "Message-ID", "Encrypted" и "MIME-Version",  должны
быть добавлены к заголовку нового общего письма, все остальные  поля  должны
игнорироваться. <p align="justify">

<STRONG>(3)</STRONG>  Заголовки  второй  и  последующих    частей    целиком
игнорируются. <p align="justify">

Например, если письмо с аудио-данными было разбито на две части, первая  из
них может выглядеть следующим образом:
<PRE>
      X-Weird-Header-1: Foo
      From: Bill@host.com
      To: joe@otherhost.com
      Subject: Audio mail
      Message-ID: &lt;id1@host.com>
      MIME-Version: 1.0
      Content-type: message/partial;
           id="ABC@host.com";
           number=1; total=2
      X-Weird-Header-1: Bar
      X-Weird-Header-2: Hello
      Message-ID: &lt;anotherid@foo.com>
      MIME-Version: 1.0
      Content-type: audio/basic
      Content-transfer-encoding: base64
   ... здесь имеет место быть первая часть закодированных аудио-данных ...
</PRE>
<p align="justify">
А вторая может выглядеть так:
<pre>
      From: Bill@host.com
      To: joe@otherhost.com
      Subject: Audio mail
      MIME-Version: 1.0
      Message-ID: &lt;id2@host.com>
      Content-type: message/partial;
           id="ABC@host.com"; number=2; total=2
   ... здесь имеет место быть вторая часть закодированных аудио-данных ...
</PRE>
<p align="justify">
После того,  как  расколотое  послание  воссоздано  заново  для  отображения
получателю, оно должно выглядеть следующим образом:
<PRE>
      X-Weird-Header-1: Foo
      From: Bill@host.com
      To: joe@otherhost.com
      Subject: Audio mail
      Message-ID: &lt;anotherid@foo.com>
      MIME-Version: 1.0
      Content-type: audio/basic
      Content-transfer-encoding: base64
   ... первая часть закодированных аудио-данных ...
   ... вторая часть закодированных аудио-данных ...
</PRE>
<p align="justify">
Замечание  по  кодированию  тела  MIME-письма,  заключенного  внутри    тела
message/partial: так  как  данные  типа  "message"  никогда  не  могут  быть
кодированы  в  Base64  или  Quoted-Printable,  следующая   проблема    может
возникнуть в случае, если тела писем типа message/partial созданы в системе,
поддерживающей  8-битный  транспорт.  Двоичные  данные  будут  разбиты    на
несколько  message/partial-объектов,   каждому    из    которых    требуется
транспортировка в двоичном виде. Если  бы  таким  объектам  пришлось  пройти
через  шлюз  в  7-битную  транспортную  среду,  их  невозможно    было    бы
перекодировать  в  сеимбитную  форму  без  ожидания  прибытия  всех   частей
послания, собирания  их  воедино  и  затем  кодирования  целого  послания  в
7-битную  кодировку  (base64  или  quoted-printable).  Поскльку   существует
вероятность, что разные части пойдут разными путями (через различные шлюзы),
то подобное решение не приемлимо. Поэтому MIME определяет, что  письма  типа
message/partial  должны  иметь  7-битную  кодировку  и  соответствующее   ей
значение поля content-transfer-encoding.  Даже  для  систем  с  транспортом,
поддерживающим "8-бит" и "binary", запрещается их использование  для  данных
message/partial. <p align="justify">

Многие почтовые агенты могут автоматически фрагментировать большие письма.
<p align="justify">

Включение  поля  "References"  в  заголовки  второй  и  последующих  частей,
ссылающегося на идентификатор предыдущей части, может оказаться полезным для
почтовых программ, понимающих и обрабатывающих ссылки. Однако, наличие этого
поля не обязательно. <p align="justify">

Поле заголовка "Encrypted" вышло из употребления, но вышеприведенные правила
обеспечивают  корректную  его  интерпретацию,  если  оно  встречается    при
обработке фрагментов типа message/partial.

<a name=733></a>
<H5>7.3.3.   Подтип 'Message/External-Body'</H5>

Этот подтип указывает на то, что тело не содержится в самом  письме,  а  на
него есть ссылка. Параметры подтипа описывают способ доступа к данным  тела
письма.
<p align="justify">

Письмо  (часть  письма) этого  подтипа   состоит    из    заголовка,    двух
последовательных  концов  строки  и  заголовка  вложенного   письма.    Если
встречается  другая  пара  концов  строки,  она  означает  конец   заголовка
вложенного  письма.  Однако,  поскольку  тело  вложенного  письма   является
внешним, оно не следует за концом заголовка. Например,
<PRE>
     Content-type: message/external-body; access-
     type=local-file;
          name="/u/nsb/Me.gif"
     Content-type:  image/gif
     Content-ID: &lt;id42@guppylake.bellcore.com>
     Content-Transfer-Encoding: binary
     ТЕЛА НЕТ!
</PRE>
<p align="justify">
Область в конце, которую можно назвать "призрачным телом", игнорируется  для
большинства писем подтипа 'external-body'.  Однако,  в  нее  можно  помещать
дополнительную  информацию,  как  например,  в  случае,    когда    параметр
'access-type' равен "mail-server". Во всех остальных случаях призрачное тело
игнорируется. <p align="justify">

Единственный всегда обязательный  параметр  для  'message/external-body'  -
"access-type". Остальные параметры могут быть или не быть  обязательными  в
зависимости от значения параметра "access-type".
<p align="justify">

Значение  этого  параметра - слово,  нечувствительное  к   регистру    букв,
означающее механизм доступа, с помощью которого файл или данные  могут  быть

получены. Значения могут быть следующими (но не ограничиваются этим  рядом):
"FTP", "ANON-FTP", "TFTP",  "AFS",  "LOCAL-FILE"  и  "MAIL-SERVER".  Будущие
возможные значения, кроме экспериментальных,  начинающихся  с  "X-",  должны
быть зарегистрированы в IANA. <p align="justify">

Дополнительно, следующие три параметра являются  необязательными  для  всех
способов доступа:
<p align="justify">
      <STRONG>EXPIRATION</STRONG> -- Дата  (RFC  822  "date-time"  синтаксис
      допускает 4 цифры в этом поле), после  которой  существование  внешних
      данных не гарантируется.<p align="justify">

      <STRONG>SIZE</STRONG>  --  размер  (в  байтах)    данных.    Позволяет
      получателю  решить,  расходовать  ли  ресурсы  на  считывание  внешних
      данных. Размер указывается для канонической формы данных (то есть,  до
      применения каких-либо преобразований).<p align="justify">

      <STRONG>PERMISSION</STRONG> -- нечувствительное к регистру букв  поле,
      говорящее о том, ожидается или нет, что  клиент  может  перезаписывать
      данные. По умолчанию или когда этот параметр  имеет  значение  "read",
      полагается, что клиент не имеет  на  это  права,  и  что  если  данные
      однажды считаны, то больше они не понадобятся. Если  PERMISSION  имеет
      значение "read-write", любая локальная копия может рассматриваться  не
      более как  кэш.  "read"  и  "write"  -  единственные  предопределенные
      значения для PERMISSION.<p align="justify">

Вложенные заголовки во ВСЕХ телах типа message/external-body ДОЛЖНЫ включать
поле  заголовка  Content-ID  для   задания    уникального    идентификатора,
указывающего на внешние данные. <p align="justify">

Обозначения, описывающие данные типа external-body, такие как  имена  файлов
или команды mail-сервера, должны быть в символьном наборе US-ASCII. <p align="justify">

Как и для типа message/partial, тело типа message/external-body должно иметь
значение content-transfer-encoding "7-bit" (по умолчанию). В частности, даже
в    системах,    поддержиавющих    8-битный    транспорт,        применение
content-transfer-encoding "8-bit"  и  "binary"  запрещено  для  данных  типа
message/external-body.
<a name=7331></a>
<H5>7.3.3.1.  Типы доступа "ftp" и "tftp"</H5>
<p align="justify">
Тип доступа по FTP или  TFTP  означает,  что  тело  сообщения  доступно  как
внешний файл по протоколу FTP [RFC-959] или TFTP  [RFC-783]  соответственно.
Для этих типов доступа обязательны следующие дополнительные параметры: <p align="justify">

      <STRONG>NAME</STRONG> -- Имя файла, содержащего данные тела письма.<p align="justify">

      <STRONG>SITE</STRONG> -- Полный доменный адрес или псевдоним  компьютера,  с  которого
      файл может быть получен по указанному протоколу.<p align="justify">

Перед тем, как начнется считывание данных по FTP, пользователь обычно должен
быть спрошен на предмет логина и пароля для машины,  указанной  в  параметре
'site'. По причинам безопасности логин и пароль не указываются как параметры
Content-Type и должны быть получены от получателя письма. <p align="justify">

Дополнительно определены следующие необязательные параметры:
<p align="justify">

      <STRONG>DIRECTORY</STRONG>  --  каталог,  содержащий  тело  письма  на
      удаленной машине.<p align="justify">

      <STRONG>MODE</STRONG> -- Нечувствительное к регистру букв  строка,  указывающая  режим
      передачи  данных. Допустимые  эначения  для  типа    доступа TFTP:
          <p align="justify">
      <STRONG>NETASCII,  OCTET</STRONG>  и  <STRONG>MAIL</STRONG>.  Для  типа  доступа  FTP:
      <STRONG>ASCII, EBCDIC, IMAGE</STRONG> и <STRONG>LOCALn,</STRONG> где
      <STRONG>n</STRONG> - десятичное целое число, обычно 8. Эти значения соответствуют типам представления <STRONG>A,  E,
      I</STRONG>  и <STRONG>Ln</STRONG>, определенным FTP-протоколом. Заметьте, что "BINARY"  и  "TENEX"
      не являются допустимыми значениями для  параметра  MODE.  Вместо  них
      должны использоваться "OCTET", "IMAGE" или "LOCAL8".  Если  параметр
      MODE отсутствует, значением по умолчанию является "NETASCII" для TFTP
      и "ASCII" для FTP.
<a name=7332></a>
<H5>7.3.3.2.  Способ досупа "anon-ftp"</H5>
<p align="justify">
Этот способ доступа идентичен "ftp", за исключением того,  что  пользователю
не  требуется  указывать  свой  логин  и  пароль  для   удаленной    машины.
FTP-протокол будет использоваться  с  логином  "anonymous"  и  email-адресом
получателя вместо пароля.
<a name=7333></a>
<H5>7.3.3.3.  Способы доступа "local-file" и "afs"</H5>
<p align="justify"> Способ доступа "local-file" означает, что тело письма доступно как  файл
на локальной машине. "afs" означает, что тело доступно как файл через  общую
файловую систему AFS. В обоих случаях  требуется  единственный  обязательный
параметр: <p align="justify">

      <STRONG>NAME</STRONG> -- Имя файла, содержащего данные тела письма.
<p align="justify">
Следующий необязательный параметр может быть  использован  для  локализации
ссылки на файл и содержит адрес сайта или сайтов, на  которых  данный  файл
виден:<p align="justify">

      <STRONG>SITE</STRONG> -- Доменный адрес машины или машин,  на  которых
      возможен доступ к файлу данных.  Допускаются  маски  с  использованием
      звездочки вместо части доменного  имени,  например,  "*.bellcore.com",
      для  обозначения  набора  машин,  на  которых  файл  виден   напрямую.
      Единственная звездочка вместо всего доменного  имени  может  означать,
      что файл, где би он ни был, виден через глобальную  файловую  систему.
<a name=7334></a>
<H5>7.3.3.4.  Способ доступа "mail-server"</H5>
<p align="justify">
Применяется, когда тело письма доступно через почтовый сервер.  Обязательный
параметр для этого способа доступа:

<p align="justify">
      <STRONG>SERVER</STRONG> -- email-адрес mail-сервера, с которого могут  быть  запрошены
      данные тела письма.
<p align="justify">
Так как  почтовые  серверы  предполагают  множество  различных  синтаксисов,
некоторые из них могут быть многострочными, полная  команда,  которую  нужно
послать на mail-сервер, не  включается  как  параметр  в  однострочное  поле
'content-type'. Вместо этого она помещается в мнимое тело,  когда  значением
поля  'content-type'   является    'message/external-body',    и    параметр
'access-tyoe' имеет значение 'mail-server'.<p align="justify">

Необязательный параметр для этого способа доступа:<p align="justify">

<STRONG>SUBJECT</STRONG> -- Subject, который будет использован  в  заголовке
      письма-запроса, которое почторый клиент получателя пошлет на указанный
      почтовый сервер  для  получения  данных  тела  письма.  Заметьте,  что
      помещение адреса сервера в subject не рекомендуется, однако,  известны
      mail-серверы, требующие этого. <p align="justify">

MIME-стандарт  не  определяет  синтаксиса  обращения  к  почтовому  серверу.
Поэтому он допускает включение полной  команды  для  mail-сервера  в  мнимое
тело. <p align="justify">

В отличие от других способов доступа, доступ через mail-сервер не синхронен,
и данные могут быть получены в непредсказуемый момент  в  будущем.  По  этой
причине  важно  иметь  механизм,  обеспечивающий  вставку   полученных    от
mail-сервера данных в исходное письмо. Mail-сервер при отправке  запрошенных
данных должен использовать то же самое значение поля Content-ID в  заголовке
письма с возвращаемыми данными, какое было  в  первоначальном  "бестелесном"
письме, чтобы облегчить работу этого механизма.
<a name=7335></a>
<H5>7.3.3.5.  Примеры и дополнительные пояснения</H5>
<p align="justify">
С появлением возможности очень широких (протяженных) файловых систем  стало
непредсказуемым, на каком наборе машин файловой системы данный  файл  будет
доступен напрямую, а на каком - нет. Поэтому, имеет смысл указывать как имя
файла, так и сетевой адрес (адреса) машин, на которых файл доступен.
<p align="justify">

Если  внешнее  тела  письма  доступно  посредством   нескольких    различных
механизмов,  отправитель    может    включить    несколько    частей    типа
message/external-body в письмо типа multipart/alternative. <p align="justify">

Однако, механизм external-body не должен быть ограничен получением удаленных
файлов. Например, можно представить использование  видеосервера  с  внешними
ссылками на видеофрагменты. <p align="justify">

Если письмо / часть письма имеет тип "message/external-body", то оно  /  она
будет  содержать  поля  заголовка  вложенного  письма.  Тело  само  по  себе
неходится  где-либо  во  вне.  Это    значит,    что    если    тело    типа
"message/external-body" содержит два последовательных конца  строки  (CRLF),
то все, что  идет  далее,  не  является  чстью  сообщения  и  просто  должно
игнорироваться.  Однако,  этот  "хвост"  -  удобное  место  для   каких-либо
дополнительных данных, которые не  могут  быть  помещены  в  поле  заголовка
Content-Type. В частности, если значение "access-type"  есть  "mail-server",
то "хвост" может содержать команды, посылаемые затем mail-серверу по адресу,
на который указывает параметр SERVER. <p align="justify">

Поля заголовка вложенного письма,  которые  на  самом  деле  являются  телом
общего письма типа "message/external-body", должны нести информацию  о  типе
содержимого  внешнего  (удаленного)  тела,  если  оно  не  является  простым
ASCII-текстом (что подразумевается  по  умолчанию),  поскольку  эти  внешние
данные сами по себе  не  имеют  заголовка,  опрпеделяющего  их  тип.  Также,
необходимо указывать  Content-transfer-encoding,  если  он  имеет  значение,
отличное  от  "7-bit".  Так,  полное  письмо  типа    message/external-body,
ссылающееся на документ в  формате  PostScript,  может  выглядеть  следующим
образом:
<PRE>
      From: Whomever
      To: Someone
      Subject: whatever
      MIME-Version: 1.0
      Message-ID: &lt;id1@host.com>
      Content-Type: multipart/alternative; boundary=42
      Content-ID: &lt;id001@guppylake.bellcore.com>
      --42
      Content-Type: message/external-body;
           name="BodyFormats.ps";
           site="thumper.bellcore.com";
           access-type=ANON-FTP;
           directory="pub";
           mode="image";
           expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"
      Content-type: application/postscript
      Content-ID: &lt;id42@guppylake.bellcore.com>
      --42
      Content-Type: message/external-body;
           name="/u/nsb/writing/rfcs/RFC-MIME.ps";
           site="thumper.bellcore.com";
           access-type=AFS
           expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"
      Content-type: application/postscript
      Content-ID: &lt;id42@guppylake.bellcore.com>
      --42
      Content-Type: message/external-body;
           access-type=mail-server
           server="listserv@bogus.bitnet";
           expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"
      Content-type: application/postscript
      Content-ID: &lt;id42@guppylake.bellcore.com>
      get RFC-MIME.DOC
      --42--
</PRE>
<p align="justify">
В приведенных примерах значение Content-transfer-encoding для внешних данных
в формате postscript полагается по умолчанию как "7bit". <p align="justify">

Заголовки  общего  и  вложенного(их) писем  (имеющих  внешнее  тело)  должны
удовлетворять тем же правилам, что и для типа message/partial  во  избежание
путаницы. <p align="justify">

Поскольку внешнее тело не пересылается в  виде  почты,  то  оно  не  обязано
удовлетворять требованиям длины строк и иметь 7-битную форму, оно может быть
просто бинарным файлом. Поэтому поле Content-Transfer-Encoding  не  является
необходимым, хотя его наличие допускается. <p align="justify">

Тело письма типа  "message/external-body"  обрабатывается  в  сответствии  с
основным синтаксисом стандарта RFC 822, в частности, все, что идет до первой
последовательной пары концов строки (CRLF), является  заголовком  письма,  а
все, что идет после, является "мнимым" телом  письма,  которое  игнорируется
для большинства типов доступа. <p align="justify">

Формальный  синтаксис  поля  заголовка  'content-type'  для  данных    типа
'message' - следующий:
<PRE>
   message_тип := "message" "/" message_подтип
   message_подтип := "rfc822"
                   / "partial" 2-3 partial_параметра
                   / "external-body" 1 external_параметр
                   / расширение (не предопределенный подтип)
   partial_параметр := (";" "id" "=" значение)
                    /  (";" "number" "=" 1*ЦИФРА)
                    /  (";" "total" "=" 1*ЦИФРА)
   ; id и number требуются всегда; total требуется для последнего  фрагмен-
   ; та послания.
   external_параметр := (";" "access-type" "=" тип_доступа)
                      / (";" "expiration" "=" дата-время)
                ; Дата-время должны быть экранированы кавычками
                      / (";" "size" "=" 1*Цифра)
                      / (";"  "permission"  "="  ("read"  /  "read-write"))
                ; Значение permission нечувствительно к регистру букв
                      / (";" "name" "=" значение)
                      / (";" "site" "=" значение)
                      / (";" "dir" "=" значение)
                      / (";" "mode" "=" значение)
                      / (";" "server" "=" значение)
                      / (";" "subject" "=" значение)
   ; access-type требуется всегда; все остальное - в зависимости от  значе-
   ; ния access-type
   тип_доступа := "ftp" / "anon-ftp" / "tftp" / "local-file"
                  / "afs" / "mail-server" /
                  / расширение (непредопределенный параметр)
   ; Нечувствителен к регистру букв
</PRE>
<a name=74></a>
<H4>7.4.  Тип 'Application'</H4>
<p align="justify">
Этот тип используется для данных, неподпадающих под остальные  категории,  в
частности, для данных, обрабатываемых прикладными почтовыми программами. Это
информация, которая должна быть обработана соответствующим  приложением  для
того,  чтобы  принять  наглядную  либо  исполняемую  для  получателя  форму.
Предполагаемое использование для этого типа включает в себя пересылку файлов
по  почте,  таблицы,  данные  для  почтовых  систем  расписания,  языки  лдя
"активной" (вычислительной) почты. (Последняя, в  частности,  может  поднять
проблемы безопасности,  которые  должны  быть  поняты  разработчиками  ПО  и
рассмотрены ниже в параграфе "Application/PostScript"). <p align="justify">

Например,  тот,  кто  занимается  расписанием  встреч,   может    определить
стандартное представление информации о датах запланированных встреч. "Умный"
пользовательский  почтовый  агент  может  использовать  эту  информацию  для
проведения диалога с пользователем, и  может  затем  посылать  в  дальнейшем
почту, основанную на том диалоге. Вообще,  существует  несколько  "активных"
почтовых языков,  разработанных  для  специализированных  программ,  которые
посылаются по почте и автоматчески запускаются в системе получателя. <p align="justify">

Подобные  приложения  могут  быть  определены  как   подтипы    для    типа
"application". Изначально  предопределено  два  подтипа:  "octet-stream"  и
"PostScript".
<p align="justify">

В общем, подтип для 'application' зачастую может быть именем приложения, для
которого предназначены пересылаемые данные. Однако,  это  не  означает,  что
любое имя прикладной программы может свободно использоваться как подтип  для
'application'. Такие употребления  (кроме  подтипов,  начинающихся  с  "x-")
должны быть зарегестрированы в IANA.

<a name=741></a>
<H5>7.4.1.  Основной подтип 'Application/Octet-Stream'</H5>
<p align="justify">
Используется для обозначения того, что тело содержит бинарные данные.  Набор
возможных параметров включает следующие (но не ограничивается ими): <p align="justify">

<STRONG>TYPE</STRONG> -- обобщенный тип или категория двоичных данных, эта  информация
      больше предназначена для получателя, чем для автоматической обработки.
<p align="justify">

<STRONG>PADDING</STRONG> -- число заполняющих битов, добавленных к  битовому
      потоку, содержащему данные,  для  формирования  байтно-ориентированных
      данных. Полезно при заключении в тело  битового  потока,  когда  общее
      число битов не кратно восьми, то есть, размеру байта. <p align="justify">

Дополнительный  параметр,  "conversions",  определенный  в  [RFC-1341],  был
исключен в последствии. <p align="justify">

В RFC 1341 также определен  параметр  <STRONG>"NAME"</STRONG>,  указывающего
имя файла, которое должно быть использовано при сохранении данных  на  диск.
Но он опять же был отменен в ожидании  введения  отдельного  поля  заголовка
Content-Disposition, которое будет определено в ближайшем будущем. <p align="justify">

Рекомендуемое  действие  для  почтовой  программы,  получившей  почту  типа
application/octet-stream, - просто предложить записать данные  в  файл  без
какого-либо преобразования, или. возможно, произвести его в соответствии  с
указанием пользователя.
<p align="justify">

Для уменьшения опасности передачи вирусных и  других  намеренно  разрушающих
систему программ по почте, строго рекомендуется,  чтобы  почтовая  программа
получателя не  производила  запуск  программы,  заданной  в  параметре  поля
"Content-Type"  (например,  в  параметре  "interpreter="),  использующей   в
качестве входных данных тело письма.
<a name=742></a>
<H5>7.4.2.  Подтип 'Application/PostScript'</H5>
<p align="justify">
Тип "application/postscript" означает, что пересылается  PostScript-документ
и требует специальной  программы  для  его  обработки.  В  настоящий  момент
используются два языка - level 1 и более поздний - level 2. <p align="justify">

PostScript-документы представляют собой интерпретируемые программы,  которые
могут содержать операторы обращения к диску и действий  с  файлами.  Поэтому
PostScript-документы  представляют  потенциальную  опасность  для    системы
получателя. <p align="justify">

В некоторых интерпретаторах PostScript могут  иметь  место  ошибки,  которые
могут быть использованы хакерами для несанкционированного доступа к  системе
получателя, и нельзя  предложить  какого-либо  специфического  действия  для
предотвращения подобной возможности, кроме исправления со временем  подобных
ошибок (если они, конечно, есть) производителями соответствующего ПО.
<a name=743></a>
<H5>7.4.3.   Другие подтипы типа Application</H5>
<p align="justify">

Ожидается, что многие подтипы типа 'Application' будут  введены  в  будущем.
MIME-совместимые почтовые программы должны интерпретировать любой незнакомый
им подтип как эквивалент 'application/octet-stream'. <p align="justify">

Формальный синтаксис дла поля 'content-type' для данных типа  'application'
дается следующим образом.
<PRE>
   application_тип :=  "application" "/" application_подтип
   application_подтип := ("octet-stream" *stream_параметр)
                       / "postscript" / расширение (непредопределенный под-
                       тип)
   stream_параметр :=  (";" "type" "=" значение)
                       / (";" "padding" "=" число_дополняющих_битов)
   число_дополняющих_битов := "0" / "1" /  "2" /  "3" / "4" / "5" / "6" /
                              / "7"
</PRE>
<a name=75></a>
<H4>7.5.  Тип 'Image'</H4>
<p align="justify">

Этот тип означает, что тело письма содержит графический объект. Его  подтипы
соответствуют конкретным графическим форматам. Их значения нечувствительны к
регистру букв. Два предопределенных подтипа -  "jpeg"  для  формата  JPEG  с
кодированием JFIF, и "gif" - для формата GIF. <p align="justify">

Формальный синтаксис поля 'Content-Type':
<PRE>
   image_тип := "image" "/" ("gif" / "jpeg" / подтип-расширение)
</PRE>
<a name=76></a>
<H4>7.6.  Тип 'Audio'</H4>
<p align="justify">
Этот подтип означает, что тело содержит аудио-данные.  Хотя  пока  еще  нет
консенсуса по "идеальному" аудио-формату для  компьютеров,  сейчас  имеется
сильная потребность в универсальном формате.
<p align="justify">

Предопределенный  подтип - "basic"  введен  в  ответ  на  это    требование,
обеспечивая минимальный примитивный аудио-формат.  Ожидается  определение  в
дальнейшем более "богатых" форматов, обеспечивающих более  высокое  качество
воспроизведения. <p align="justify">

Содержимое тела, имеющего подтип "audio/basic", -  аудио-данные  в  8-битной
форме, кодированные с использованием ISDN  mu-law.  Формат,  соответствующий
этому  подтипу,  предполагает  максимальную  частоту  звучания  8000  Hz   и
единственный канал. <p align="justify">

Формальный синтаксис лдя поля 'Content-Type':
<PRE>
   audio_тип := "audio" "/" ("basic" / подтип-расширение)
</PRE>
<a name=77></a>
<H4>7.7.  Тип 'Video'</H4>
<p align="justify">
Этот тип означает, что в теле письма  содержится  анимационное  изображение,
возможно, со звуком и цветом. Термин "video" используется безотносительно  к
технологии  получения  подвижного  во  времени  изображения.  Подтип  "mpeg"
указывает на видео, кодированное в соответствии со стандартом MPEG. <p align="justify">

Хотя MIME-стандарт запрещает смешение разнородных  мультимедийных  данных  в
одном теле (письма или части письма), многие так называемые  "video"-форматы
включают синхронизированный звук, что допускается для подтипов типа "video".
<p align="justify">

Формальный синтаксис лдя поля 'Content-Type':
<PRE>
   video-type := "video" "/" ("mpeg" / подтип-расширение)
</PRE>
<a name=78></a>
<H4>7.8.  Экспериментальные значения поля 'Content-Type'</H4>
<p align="justify">
Значение типа, начинающееся с "X-", считается частным,  предназначенным  для
использования по договоренности между двумя или более  почтовыми  системами.
Публично  определенные  (регестрированные)  значения  никогда   не    должны
начинаться с префикса "X-". <p align="justify">

В  общем,  использование  X-типов  верхнего   уровня    не    рекомендуется.
Производители почтового ПО должны по возможности  обходиться  использованием
X-подтипов для  предопределенных  типов.  Во  многих  случаях  использование
экспериментального подтипа более приемлимо, нежели типа верхнего уровня.
<H4>Все определенные  на  сегодняшний  день  типы  и  подтипы</H4>
<TABLE cellspacing=2 cellpadding=3 border=1>
<TR>
<TH>ТИП</TH><TH>ПОДТИП</TH>
</TR>
<TR>
<TD  VALIGN=TOP ROWSPAN=4>text</TD><TD>plain</TD> </TR> <TR>
                <TD>richtext</TD>
</TR>
<TR>
                <TD>enriched</TD>
</TR>
<TR>
                <TD>tab-separated-values</TD>
</TR>
<TR>
<TD VALIGN=TOP ROWSPAN=6>multipart</TD><TD>mixed</TD>
</TR>
<TR>
                <TD>alternative</TD>
</TR>
<TR>
                <TD>digest</TD>
</TR>
<TR>
                <TD>parallel</TD>
</TR>
<TR>
                <TD>appledouble</TD>
</TR>
<TR>
                <TD>header-set</TD>
</TR>
<TR>
<TD VALIGN=TOP ROWSPAN=4>message</TD><TD>rfc822</TD>
</TR>
<TR>
                <TD>partial</TD>
</TR>
<TR>
                <TD>external-body</TD>
</TR>
<TR>
                <TD>news</TD>
</TR>
<TR>
<TD VALIGN=TOP ROWSPAN=21>application</TD><TD>octet-stream</TD>
</TR>
<TR>
                <TD>postscript</TD>
</TR>
<TR>
                <TD>oda</TD>
</TR>
<TR>
                <TD>atomicmail</TD>
</TR>
<TR>
                <TD>andrew-inset</TD>
</TR>
<TR>
                <TD>slate</TD>
</TR>
<TR>
                <TD>wita</TD>
</TR>
<TR>
                <TD>dec-dx</TD>
</TR>
<TR>
                <TD>dca-rft</TD>
</TR>
<TR>
                <TD>activemessage</TD>
</TR>
<TR>
                <TD>rtf</TD>
</TR>
<TR>
                <TD>applefile</TD>
</TR>
<TR>
                <TD>mac-binhex40</TD>
</TR>
<TR>
                <TD>news-message-id</TD>
</TR>
<TR>
                <TD>news-transmission</TD>
</TR>
<TR>
                <TD>wordperfect5.1</TD>
</TR>
<TR>
                <TD>pdf</TD>
</TR>
<TR>
                <TD>zip</TD>
</TR>
<TR>
                <TD>macwriteii</TD>
</TR>
<TR>
                <TD>msword</TD>
</TR>
<TR>
                <TD>remote-printing</TD>
</TR>
<TR>
<TD VALIGN=TOP ROWSPAN=4>image</TD><TD>jpeg</TD>
</TR>
<TR>
                <TD>gif</TD>
</TR>
<TR>
                <TD>ief</TD>
</TR>
<TR>
                <TD>tiff</TD>
</TR>
<TR>
<TD>audio</TD><TD>basic</TD>
</TR>
<TR>
<TD VALIGN=TOP ROWSPAN=2>video</TD><TD>mpeg</TD>
</TR>
<TR>
                <TD>quicktime</TD>
</TR>
</TABLE>
<p align="justify">
Значения полей Content-Type и subtype, а также  другие  параметры  заголовка
являются  чувствительными  к  регистру  букв,  если  только  не    оговорены
исключения для конкретного значения параметра.
<P>
<!EMBED SRC="/cgi-bin/Count.cgi?df=vt-miem.2&ft=0&tr=T&dd=timex" width=0 height=0>
<CENTER>
<FONT SIZE="1"><I><B>This page is located at </B></I><A HREF="http://vt.miem.edu.ru">vt.miem.edu.ru</A>
<BR>
<B><I>Updated: </I>Saturday, 11-Nov-2000 19:26:20 MSK</B>
<br>
About bugs mail to <a href="mailto:as@vt.miem.edu.ru">WebMaster</a>
or <a href="mailto:grand@vt.miem.edu.ru">WebMaster</a>
</FONT>
</CENTER>
</P>
<hr>
<!-- RLE code START -->
<!-- pt language="JavaScript">
<!+-
var RndNum4NoCash = Math.round(Math.random() * 1000000000);
document.write(
'<iframe src="http://ad.adriver.ru/cgi-bin/erle.cgi'
+ '?sid=38003&target=blank&bt=1&pz=0&rnd=' + RndNum4NoCash
+ '" frameborder=0 vspace=0 hspace=0 width=468 height=60 marginwidth=0 marginheight=0 scrolling=no>'
+ '<a href="http://ad.adriver.ru/cgi-bin/click.cgi'
+ '?sid=38003&bt=1&pz=0&rnd=' + RndNum4NoCash + '" target=_blank>'
+ '<img src="http://ad.adriver.ru/cgi-bin/rle.cgi?'
+ 'sid=38003&bt=1&pz=0&rnd=' + RndNum4NoCash
+ '" alt="-AdRiver-" border=0 width=468 height=60></a></iframe>')
// +->
</scri-->
<N- cript>
<AD- me src="http://ad.adriver.ru/cgi-bin/erle.cgi?sid=38003&target=blank&bt=1&pz=0&rnd=173020642" frameborder=0 vspace=0 hspace=0 width=468 height=60 marginwidth=0 marginheight=0 scrolling=no>
<a href="http://ad.adriver.ru/cgi-bin/click.cgi?sid=38003&bt=1&pz=0&rnd=173020642" target=_blank>
[AD]<AD- "http://ad.adriver.ru/cgi-bin/rle.cgi?sid=38003&bt=1&pz=0&rnd=173020642" alt="-AdRiver-" border=0 width=468 height=60></a><AD- ame>
<N- script>
<!-- RLE code END -->
</BODY>
</HTML>

